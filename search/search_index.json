{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TeleopXR","text":"<p>Transform your VR/AR headset into a powerful, precise robot controller. TeleopXR provides a lightweight, installation-free teleoperation interface with low-latency video streaming and full WebXR state tracking. Check the full documentation for the latest guides and API references.</p> <p> </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd76\ufe0f VR/Passthrough: Seamlessly switch between fully immersive VR and   high-fidelity AR Passthrough modes, allowing you to choose between total   focus and situational awareness.</li> <li>\ud83d\udce1 WebRTC Video Streaming: Get ultra-low latency, real-time video   feedback directly in the headset, providing a near-instantaneous visual   link to your robot's perspective.</li> <li>\ud83e\udd16 Robot Visualization: Benefit from real-time 3D visualization of the   robot model, ensuring your digital twin is always perfectly synchronized   with the physical robot's state.</li> <li>\ud83d\udd79\ufe0f Realtime Teleoperation based on Whole-Body IK: Achieve precise and   intuitive control through advanced Whole-Body Inverse Kinematics, enabling   complex coordination with minimal effort.</li> </ul>"},{"location":"#quick-start-demo","title":"\ud83d\ude80 Quick Start (Demo)","text":"<p>Use the built-in demo to verify connectivity and visualize the XR state data in real-time.</p>"},{"location":"#installation","title":"Installation","text":"<p>Basic installation (teleop mode only):</p> <pre><code>pip install teleop-xr\n</code></pre> <p>With IK support:</p> <p>The IK solver requires additional dependencies. Install them with:</p> <pre><code>pip install teleop-xr\n# Install IK dependencies from PyPI\npip install spatialmath-python&gt;=1.1.15 gitpython&gt;=3.1.46 xacro&gt;=2.1.1 \\\n    filelock&gt;=3.20.3 viser&gt;=1.0.21\n# Install pyroki and ballpark from GitHub (not available on PyPI)\npip install git+https://github.com/chungmin99/pyroki.git\npip install git+https://github.com/chungmin99/ballpark.git\n</code></pre> <p>Note: <code>pyroki</code> and <code>ballpark</code> are not available on PyPI, so <code>pip install teleop-xr[ik]</code> will not work. Install them manually from GitHub as shown above.</p> <p>Alternatively, if you have <code>npm</code> installed, install everything from source:</p> <pre><code>pip install \"teleop-xr[ik]@git+https://github.com/qrafty-ai/teleop_xr\"\n</code></pre>"},{"location":"#running-the-demo","title":"Running the Demo","text":"<pre><code>python -m teleop_xr.demo\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ol> <li>Open the displayed URL (<code>https://&lt;ip&gt;:4443</code>) in your headset.</li> <li>Enter VR mode.</li> <li>Observe the live state data and event logs in your terminal.</li> </ol>"},{"location":"#modes","title":"Modes","text":"<p>The demo supports two operation modes:</p> <ul> <li>Teleop Mode (Default): Visualizes raw XR state data and button events.</li> </ul> <pre><code>python -m teleop_xr.demo --mode teleop\n</code></pre> <ul> <li>IK Mode: Enables the high-performance IK solver (configured for Unitree   H1 by default). Requires IK dependencies installed.</li> </ul> <pre><code>python -m teleop_xr.demo --mode ik\n</code></pre>"},{"location":"#supported-robots-ik","title":"Supported Robots (IK)","text":"<p>TeleopXR currently includes the following built-in robot classes:</p> <ul> <li><code>h1</code> - Unitree H1 whole-body model for bimanual teleoperation.</li> <li><code>franka</code> - Franka Emika Panda single-arm manipulator.</li> <li><code>so101</code> - SO101 single-arm model   with relaxed 5-DOF IK.</li> <li><code>openarm</code> - OpenArm bimanual configuration from   <code>openarm_description</code>.</li> <li><code>teaarm</code> - Custom openarm extension with waist   joints.</li> </ul> <p>Use <code>--list-robots</code> to show all currently registered robots in your environment.</p>"},{"location":"#documentation","title":"\ud83d\udcd6 Documentation","text":"<p>For detailed guides on integrating TeleopXR into your own projects, including the Generic Python API, ROS2 Interface, and dora-rs Interface, visit the official documentation site.</p>"},{"location":"#development","title":"Development","text":"<p>For developers contributing to TeleopXR or customizing the frontend:</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+ with pip</li> <li>uv (recommended for development)</li> <li>Node.js &amp; npm (for WebXR frontend)</li> </ul>"},{"location":"#setup","title":"Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/qrafty-ai/teleop_xr.git\ncd teleop_xr\n</code></pre> <ol> <li>Install Python dependencies:</li> </ol> <p>Option A: Using uv (recommended)</p> <pre><code>uv sync\n</code></pre> <p>Option B: Using pip</p> <pre><code>pip install -e .\n\n# For IK support, install additional dependencies:\npip install spatialmath-python&gt;=1.1.15 gitpython&gt;=3.1.46 xacro&gt;=2.1.1 \\\n    filelock&gt;=3.20.3 viser&gt;=1.0.21\npip install git+https://github.com/chungmin99/pyroki.git\npip install git+https://github.com/chungmin99/ballpark.git\n</code></pre> <ol> <li>Build the WebXR frontend:</li> </ol> <pre><code>cd webxr\nnpm install\nnpm run build\n</code></pre> <p>(The build output will be used by the Python server)</p> <ol> <li>Run from source:</li> </ol> <pre><code># From the root directory\n# With uv:\nuv run python -m teleop_xr.demo\n\n# Or with pip:\npython -m teleop_xr.demo\n</code></pre>"},{"location":"#note-on-ik-dependencies","title":"Note on IK Dependencies","text":"<p>The IK solver requires <code>pyroki</code> and <code>ballpark</code>, which are not on PyPI. During development with <code>uv</code>, these packages are automatically installed from git. For pip-based installations, install them manually from GitHub as shown above.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project is forked from SpesRobotics/teleop.</p> <p>We also leverage powerful libraries for robotics:</p> <ul> <li>Pyroki: For high-performance,   differentiable Inverse Kinematics and collision checking.</li> <li>Ballpark: For robust collision   geometry generation and sphere decomposition.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0. See the LICENSE file for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>This page provides a detailed reference for every module in the <code>teleop_xr</code> package.</p>"},{"location":"api/#core-module","title":"Core Module","text":""},{"location":"api/#teleop_xr_1","title":"teleop_xr","text":""},{"location":"api/#teleop_xr","title":"<code>teleop_xr</code>","text":""},{"location":"api/#teleop_xr.Teleop","title":"<code>Teleop</code>","text":"<p>Teleop class for controlling a robot remotely using FastAPI and WebSockets.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>TeleopSettings</code> <p>Configuration settings for the teleop server.</p> required <code>video_sources</code> <code>Optional[dict[str, VideoSource]]</code> <p>Dictionary of video sources.</p> <code>None</code> Source code in <code>teleop_xr/__init__.py</code> <pre><code>class Teleop:\n    \"\"\"\n    Teleop class for controlling a robot remotely using FastAPI and WebSockets.\n\n    Args:\n        settings (TeleopSettings): Configuration settings for the teleop server.\n        video_sources (Optional[dict[str, VideoSource]]): Dictionary of video sources.\n    \"\"\"\n\n    def __init__(\n        self,\n        settings: TeleopSettings,\n        video_sources: Optional[dict[str, VideoSource]] = None,\n    ):\n        self.__logger = logging.getLogger(\"teleop\")\n        self.__logger.setLevel(logging.INFO)\n        if not self.__logger.handlers:\n            self.__logger.addHandler(logging.StreamHandler())\n\n        self.__settings = settings\n        self.__camera_views = self.__settings.camera_views\n\n        self.__relative_pose_init = None\n        self.__absolute_pose_init = None\n        self.__previous_received_pose = None\n        self.__callbacks = []\n        self.__pose = np.eye(4)\n        self.__last_joint_state: Optional[Dict[str, float]] = None\n\n        euler = self.__settings.natural_phone_orientation_euler\n        self.__natural_phone_pose = t3d.affines.compose(\n            self.__settings.natural_phone_position,\n            t3d.euler.euler2mat(euler[0], euler[1], euler[2]),\n            [1, 1, 1],\n        )\n\n        self.__app = FastAPI()\n        self.__app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n        self.__manager = ConnectionManager()\n\n        self.__ws_connect_lock = asyncio.Lock()\n        self.__control_lock = asyncio.Lock()\n        self.__controller_client_id: Optional[str] = None\n        self.__controller_ws: Optional[WebSocket] = None\n        self.__controller_last_seen_s: float = 0.0\n        self.__ws_client_ids: dict[WebSocket, str] = {}\n\n        self.__video_streams: list[VideoStreamConfig] = []\n        self.__video_sources: dict[str, VideoSource] = video_sources or {}\n        self.__video_sessions: dict[WebSocket, VideoStreamManager] = {}\n\n        self.robot_vis: Optional[RobotVisModule] = None\n        if self.__settings.robot_vis:\n            self.robot_vis = RobotVisModule(self.__app, self.__settings.robot_vis)\n\n        if self.__camera_views is not None and not self.__video_streams:\n            self.set_video_streams(build_video_streams(self.__camera_views))\n\n        # Configure logging\n        logging.getLogger(\"uvicorn.access\").setLevel(logging.WARNING)\n        self.__setup_routes()\n\n    @property\n    def input_mode(self):\n        return self.__settings.input_mode\n\n    @property\n    def app(self) -&gt; FastAPI:\n        return self.__app\n\n    def set_pose(self, pose: np.ndarray) -&gt; None:\n        \"\"\"\n        Set the current pose of the end-effector.\n\n        Parameters:\n        - pose (np.ndarray): A 4x4 transformation matrix representing the pose.\n        \"\"\"\n        self.__pose = pose\n\n    def __convert_pose_to_ros(self, pose: dict[str, Any] | None) -&gt; None:\n        if not pose or \"position\" not in pose or \"orientation\" not in pose:\n            return\n\n        position = pose[\"position\"]\n        orientation = pose[\"orientation\"]\n        position_arr = np.array([position[\"x\"], position[\"y\"], position[\"z\"]])\n        quat = np.array(\n            [\n                orientation[\"w\"],\n                orientation[\"x\"],\n                orientation[\"y\"],\n                orientation[\"z\"],\n            ]\n        )\n\n        pose_rub = t3d.affines.compose(\n            position_arr, t3d.quaternions.quat2mat(quat), [1, 1, 1]\n        )\n        pose_flu = TF_RUB2FLU @ pose_rub\n        pose_flu[:3, :3] = pose_flu[:3, :3] @ TF_RUB2FLU_ROT_INV\n\n        position_flu = pose_flu[:3, 3]\n        quat_flu = t3d.quaternions.mat2quat(pose_flu[:3, :3])\n\n        pose[\"position\"] = {\n            \"x\": float(position_flu[0]),\n            \"y\": float(position_flu[1]),\n            \"z\": float(position_flu[2]),\n        }\n        pose[\"orientation\"] = {\n            \"w\": float(quat_flu[0]),\n            \"x\": float(quat_flu[1]),\n            \"y\": float(quat_flu[2]),\n            \"z\": float(quat_flu[3]),\n        }\n\n    def __convert_devices_to_ros(self, devices: list[dict[str, Any]]) -&gt; None:\n        for device in devices:\n            self.__convert_pose_to_ros(device.get(\"pose\"))\n            self.__convert_pose_to_ros(device.get(\"gripPose\"))\n\n            joints = device.get(\"joints\")\n            if isinstance(joints, dict):\n                for joint_pose in joints.values():\n                    self.__convert_pose_to_ros(joint_pose)\n\n    def subscribe(self, callback: Callable[[np.ndarray, Any], None]) -&gt; None:\n        \"\"\"\n        Subscribe to receive updates from the teleop module.\n\n        Parameters:\n            callback (Callable[[np.ndarray, dict[str, Any]], None]): A callback function that will be called when pose updates are received.\n                The callback function should take two arguments:\n                    - np.ndarray: A 4x4 transformation matrix representing the end-effector target pose.\n                    - dict[str, Any]: A dictionary containing additional information.\n        \"\"\"\n        self.__callbacks.append(callback)\n\n    def __notify_subscribers(self, pose, message):\n        for callback in self.__callbacks:\n            callback(pose, message)\n\n    def set_video_streams(self, payload: Any) -&gt; None:\n        self.__video_streams = parse_video_config(payload)\n\n    def clear_video_streams(self) -&gt; None:\n        self.__video_streams = []\n\n    async def _start_video_session(self, websocket: WebSocket) -&gt; None:\n        sources = self.__video_sources\n        if not sources and self.__video_streams:\n            sources = build_sources(self.__video_streams)\n\n        manager = VideoStreamManager(sources)\n        self.__video_sessions[websocket] = manager\n        offer = await manager.create_offer()\n        await self.__manager.send_personal_message(\n            json.dumps(\n                {\"type\": \"video_offer\", \"data\": {\"sdp\": offer.sdp, \"type\": offer.type}}\n            ),\n            websocket,\n        )\n\n    async def _handle_video_message(self, websocket: WebSocket, message: Any) -&gt; None:\n        msg_type = message.get(\"type\")\n        self.__logger.info(f\"Received video message: {msg_type}\")\n\n        if msg_type == \"video_request\":\n            self.__logger.info(\"Starting video session\")\n            await self._start_video_session(websocket)\n            return\n\n        session = self.__video_sessions.get(websocket)\n        if session:\n            self.__logger.debug(f\"Routing {msg_type} to session\")\n            await route_video_message(session, message)\n        else:\n            self.__logger.warning(\n                f\"No active video session for websocket, ignoring {msg_type}\"\n            )\n\n    def apply(self, position, orientation, move=True, scale=1.0, info=None):\n        if info is None:\n            info = {}\n\n        position_arr = np.array([position[\"x\"], position[\"y\"], position[\"z\"]])\n        quat = np.array(\n            [orientation[\"w\"], orientation[\"x\"], orientation[\"y\"], orientation[\"z\"]]\n        )\n\n        if not move:\n            self.__relative_pose_init = None\n            self.__absolute_pose_init = None\n            self.__notify_subscribers(self.__pose, info)\n            return\n\n        received_pose = t3d.affines.compose(\n            position_arr, t3d.quaternions.quat2mat(quat), [1, 1, 1]\n        )\n        received_pose = received_pose @ self.__natural_phone_pose\n\n        # Pose jump protection\n        if self.__previous_received_pose is not None:\n            if not are_close(\n                received_pose,\n                self.__previous_received_pose,\n                lin_tol=0.05,\n                ang_tol=math.radians(35),\n            ):\n                self.__logger.warning(\"Pose jump detected, resetting the pose\")\n                self.__relative_pose_init = None\n                self.__previous_received_pose = received_pose\n                return\n        self.__previous_received_pose = received_pose\n\n        # Accumulate the pose and publish\n        if self.__relative_pose_init is None:\n            self.__relative_pose_init = received_pose\n            self.__absolute_pose_init = self.__pose\n            self.__previous_received_pose = None\n\n        assert self.__absolute_pose_init is not None\n        relative_position = received_pose[:3, 3] - self.__relative_pose_init[:3, 3]\n        relative_orientation = received_pose[:3, :3] @ np.linalg.inv(\n            self.__relative_pose_init[:3, :3]\n        )\n\n        if scale &gt; 1.0:\n            relative_position *= scale\n\n        self.__pose = np.eye(4)\n        self.__pose[:3, 3] = self.__absolute_pose_init[:3, 3] + relative_position\n        self.__pose[:3, :3] = relative_orientation @ self.__absolute_pose_init[:3, :3]\n\n        # Apply scale\n        if scale &lt; 1.0:\n            self.__pose = interpolate_transforms(\n                self.__absolute_pose_init, self.__pose, scale\n            )\n\n        # Notify the subscribers\n        self.__notify_subscribers(self.__pose, info)\n\n    def __handle_xr_state(self, message):\n        input_mode = self.__settings.input_mode\n        devices = message.get(\"devices\", [])\n\n        self.__convert_devices_to_ros(devices)\n\n        # Log fetch latency if present\n        fetch_latency = message.get(\"fetch_latency_ms\")\n        if fetch_latency is not None:\n            self.__logger.debug(f\"XR input fetch latency: {fetch_latency:.2f}ms\")\n\n        filtered_devices = []\n        for d in devices:\n            role = d.get(\"role\")\n            if role == \"head\":\n                filtered_devices.append(d)\n            elif role == \"controller\" and input_mode in [\"controller\", \"auto\"]:\n                filtered_devices.append(d)\n\n        message[\"devices\"] = filtered_devices\n\n        # Derive pose from controller device (prefer right then left)\n        target_device = None\n        for handedness in [\"right\", \"left\"]:\n            for d in filtered_devices:\n                if d.get(\"role\") == \"controller\" and d.get(\"handedness\") == handedness:\n                    target_device = d\n                    break\n            if target_device:\n                break\n\n        if target_device:\n            pose_data = target_device.get(\"gripPose\")\n            if pose_data:\n                self.apply(\n                    pose_data[\"position\"],\n                    pose_data[\"orientation\"],\n                    move=True,\n                    scale=1.0,\n                    info=message,\n                )\n                return\n\n        # Fallback to head pose\n        for d in filtered_devices:\n            if d.get(\"role\") == \"head\":\n                pose_data = d.get(\"pose\")\n                if pose_data:\n                    self.apply(\n                        pose_data[\"position\"],\n                        pose_data[\"orientation\"],\n                        move=True,\n                        scale=1.0,\n                        info=message,\n                    )\n                    return\n\n    async def publish_joint_state(self, joints: Dict[str, float]):\n        self.__last_joint_state = joints\n        if self.robot_vis:\n            await self.robot_vis.broadcast_state(self.__manager, joints)\n\n    def __setup_routes(self):\n        static_dir, index_path, mount_path, mount_name = _resolve_frontend_paths(\n            THIS_DIR\n        )\n\n        @self.__app.get(\"/\")\n        async def index():\n            return FileResponse(index_path)\n\n        @self.__app.websocket(\"/ws\")\n        async def websocket_endpoint(websocket: WebSocket):\n            control_timeout_s = 5.0\n\n            await websocket.accept()\n\n            try:\n                await asyncio.wait_for(self.__ws_connect_lock.acquire(), timeout=0.05)\n            except asyncio.TimeoutError:\n                await websocket.send_text(\n                    json.dumps(\n                        {\n                            \"type\": \"connection_error\",\n                            \"data\": {\n                                \"reason\": \"connecting\",\n                                \"message\": \"WebSocket busy: another client is connecting.\",\n                            },\n                        }\n                    )\n                )\n                await websocket.close()\n                return\n\n            try:\n                await self.__manager.register(websocket)\n\n                # Send config message on connect\n                await websocket.send_text(\n                    json.dumps(\n                        {\n                            \"type\": \"config\",\n                            \"data\": self.__settings.model_dump(),\n                        }\n                    )\n                )\n\n                if self.robot_vis:\n                    await websocket.send_text(\n                        json.dumps(\n                            {\n                                \"type\": \"robot_config\",\n                                \"data\": self.robot_vis.get_frontend_config(),\n                            }\n                        )\n                    )\n                    if self.__last_joint_state:\n                        await websocket.send_text(\n                            json.dumps(\n                                {\n                                    \"type\": \"robot_state\",\n                                    \"data\": {\"joints\": self.__last_joint_state},\n                                }\n                            )\n                        )\n\n                if self.__video_streams:\n                    await self.__manager.send_personal_message(\n                        json.dumps(\n                            {\n                                \"type\": \"video_config\",\n                                \"data\": {\n                                    \"streams\": [\n                                        s.__dict__ for s in self.__video_streams\n                                    ]\n                                },\n                            }\n                        ),\n                        websocket,\n                    )\n            finally:\n                self.__ws_connect_lock.release()\n\n            self.__logger.info(\"Client connected\")\n\n            async def close_video_sessions_for_client_id(\n                client_id_to_close: str,\n            ) -&gt; None:\n                to_close: list[tuple[WebSocket, VideoStreamManager]] = []\n                for ws, session in list(self.__video_sessions.items()):\n                    ws_id = self.__ws_client_ids.get(ws)\n                    if ws_id == client_id_to_close:\n                        to_close.append((ws, session))\n\n                for ws, session in to_close:\n                    await session.close()\n                    self.__video_sessions.pop(ws, None)\n\n            async def close_video_sessions_not_matching(controller_id: str) -&gt; None:\n                to_close: list[tuple[WebSocket, VideoStreamManager]] = []\n                for ws, session in list(self.__video_sessions.items()):\n                    ws_id = self.__ws_client_ids.get(ws)\n                    if ws_id != controller_id:\n                        to_close.append((ws, session))\n\n                for ws, session in to_close:\n                    await session.close()\n                    self.__video_sessions.pop(ws, None)\n\n            async def check_or_claim_control(\n                claimed_client_id: str,\n            ) -&gt; tuple[bool, Optional[str]]:\n                expired_controller: Optional[str] = None\n                newly_claimed: Optional[str] = None\n\n                async with self.__control_lock:\n                    now = time.monotonic()\n                    if (\n                        self.__controller_client_id is not None\n                        and (now - self.__controller_last_seen_s) &gt; control_timeout_s\n                    ):\n                        expired_controller = self.__controller_client_id\n                        self.__controller_client_id = None\n                        self.__controller_ws = None\n                        self.__controller_last_seen_s = 0.0\n\n                    if self.__controller_client_id is None:\n                        self.__controller_client_id = claimed_client_id\n                        newly_claimed = claimed_client_id\n\n                    in_control = self.__controller_client_id == claimed_client_id\n                    if in_control:\n                        self.__controller_ws = websocket\n                        self.__controller_last_seen_s = now\n\n                    controller_id = self.__controller_client_id\n\n                if expired_controller is not None:\n                    await close_video_sessions_for_client_id(expired_controller)\n\n                if newly_claimed is not None:\n                    await close_video_sessions_not_matching(newly_claimed)\n\n                return in_control, controller_id\n\n            try:\n                while True:\n                    data = await websocket.receive_text()\n                    message = json.loads(data)\n\n                    msg_type = message.get(\"type\")\n                    client_id = message.get(\"client_id\")\n                    if isinstance(client_id, str) and client_id:\n                        self.__ws_client_ids[websocket] = client_id\n\n                    if msg_type == \"control_check\":\n                        if not isinstance(client_id, str) or not client_id:\n                            await websocket.send_text(\n                                json.dumps(\n                                    {\n                                        \"type\": \"control_status\",\n                                        \"data\": {\n                                            \"in_control\": False,\n                                            \"controller_client_id\": self.__controller_client_id,\n                                        },\n                                    }\n                                )\n                            )\n                            continue\n\n                        in_control, controller_id = await check_or_claim_control(\n                            client_id\n                        )\n\n                        await websocket.send_text(\n                            json.dumps(\n                                {\n                                    \"type\": \"control_status\",\n                                    \"data\": {\n                                        \"in_control\": in_control,\n                                        \"controller_client_id\": controller_id,\n                                    },\n                                }\n                            )\n                        )\n                        continue\n\n                    if msg_type == \"xr_state\":\n                        if not isinstance(client_id, str) or not client_id:\n                            await websocket.send_text(\n                                json.dumps(\n                                    {\n                                        \"type\": \"deny\",\n                                        \"data\": {\n                                            \"reason\": \"missing_client_id\",\n                                            \"controller_client_id\": self.__controller_client_id,\n                                        },\n                                    }\n                                )\n                            )\n                            continue\n\n                        allowed, controller_id = await check_or_claim_control(client_id)\n                        if not allowed:\n                            await websocket.send_text(\n                                json.dumps(\n                                    {\n                                        \"type\": \"deny\",\n                                        \"data\": {\n                                            \"reason\": \"not_in_control\",\n                                            \"controller_client_id\": controller_id,\n                                        },\n                                    }\n                                )\n                            )\n                            continue\n\n                        self.__handle_xr_state(message[\"data\"])\n                        continue\n\n                    if msg_type in {\"video_request\", \"video_answer\", \"video_ice\"}:\n                        if not isinstance(client_id, str) or not client_id:\n                            await websocket.send_text(\n                                json.dumps(\n                                    {\n                                        \"type\": \"deny\",\n                                        \"data\": {\n                                            \"reason\": \"missing_client_id\",\n                                            \"controller_client_id\": self.__controller_client_id,\n                                        },\n                                    }\n                                )\n                            )\n                            continue\n\n                        allowed, controller_id = await check_or_claim_control(client_id)\n                        if not allowed:\n                            await websocket.send_text(\n                                json.dumps(\n                                    {\n                                        \"type\": \"deny\",\n                                        \"data\": {\n                                            \"reason\": \"not_in_control\",\n                                            \"controller_client_id\": controller_id,\n                                        },\n                                    }\n                                )\n                            )\n                            continue\n\n                        await self._handle_video_message(websocket, message)\n                        continue\n\n                    if msg_type == \"console_log\":\n                        # Stream console logs from WebXR to terminal\n                        log_data = message.get(\"data\", {})\n                        level = log_data.get(\"level\", \"log\")\n                        msg = log_data.get(\"message\", \"\")\n\n                        # Suppress spammy WS errors from WebXR\n                        if \"WS Error\" in msg and \"isTrusted\" in msg:\n                            continue\n\n                        self.__logger.info(f\"[WebXR:{level}] {msg}\")\n\n            except WebSocketDisconnect:\n                pass\n            finally:\n                disconnected_client_id = self.__ws_client_ids.pop(websocket, None)\n                if disconnected_client_id is not None:\n                    async with self.__control_lock:\n                        if (\n                            self.__controller_ws is websocket\n                            and self.__controller_client_id == disconnected_client_id\n                        ):\n                            self.__controller_client_id = None\n                            self.__controller_ws = None\n                            self.__controller_last_seen_s = 0.0\n\n                session = self.__video_sessions.pop(websocket, None)\n                if session:\n                    await session.close()\n                await self.__manager.disconnect(websocket)\n                self.__logger.info(\"Client disconnected\")\n\n        self.__app.mount(mount_path, StaticFiles(directory=static_dir), name=mount_name)\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Runs the teleop server. This method is blocking.\n        \"\"\"\n        self.__logger.info(self.__settings.model_dump_json())\n        self.__logger.info(\n            f\"Server started at {self.__settings.host}:{self.__settings.port}\"\n        )\n        self.__logger.info(\n            f\"The phone web app should be available at https://{get_local_ip()}:{self.__settings.port}\"\n        )\n\n        ssl_keyfile = os.path.join(THIS_DIR, \"key.pem\")\n        ssl_certfile = os.path.join(THIS_DIR, \"cert.pem\")\n\n        uvicorn.run(\n            self.__app,\n            host=self.__settings.host,\n            port=self.__settings.port,\n            ssl_keyfile=ssl_keyfile,\n            ssl_certfile=ssl_certfile,\n            log_level=\"warning\",\n        )\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stops the teleop server.\n        \"\"\"\n        # FastAPI/uvicorn handles shutdown automatically\n        pass\n</code></pre>"},{"location":"api/#teleop_xr.Teleop.run","title":"<code>run()</code>","text":"<p>Runs the teleop server. This method is blocking.</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Runs the teleop server. This method is blocking.\n    \"\"\"\n    self.__logger.info(self.__settings.model_dump_json())\n    self.__logger.info(\n        f\"Server started at {self.__settings.host}:{self.__settings.port}\"\n    )\n    self.__logger.info(\n        f\"The phone web app should be available at https://{get_local_ip()}:{self.__settings.port}\"\n    )\n\n    ssl_keyfile = os.path.join(THIS_DIR, \"key.pem\")\n    ssl_certfile = os.path.join(THIS_DIR, \"cert.pem\")\n\n    uvicorn.run(\n        self.__app,\n        host=self.__settings.host,\n        port=self.__settings.port,\n        ssl_keyfile=ssl_keyfile,\n        ssl_certfile=ssl_certfile,\n        log_level=\"warning\",\n    )\n</code></pre>"},{"location":"api/#teleop_xr.Teleop.set_pose","title":"<code>set_pose(pose)</code>","text":"<p>Set the current pose of the end-effector.</p> <p>Parameters: - pose (np.ndarray): A 4x4 transformation matrix representing the pose.</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def set_pose(self, pose: np.ndarray) -&gt; None:\n    \"\"\"\n    Set the current pose of the end-effector.\n\n    Parameters:\n    - pose (np.ndarray): A 4x4 transformation matrix representing the pose.\n    \"\"\"\n    self.__pose = pose\n</code></pre>"},{"location":"api/#teleop_xr.Teleop.stop","title":"<code>stop()</code>","text":"<p>Stops the teleop server.</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stops the teleop server.\n    \"\"\"\n    # FastAPI/uvicorn handles shutdown automatically\n    pass\n</code></pre>"},{"location":"api/#teleop_xr.Teleop.subscribe","title":"<code>subscribe(callback)</code>","text":"<p>Subscribe to receive updates from the teleop module.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ndarray, dict[str, Any]], None]</code> <p>A callback function that will be called when pose updates are received. The callback function should take two arguments:     - np.ndarray: A 4x4 transformation matrix representing the end-effector target pose.     - dict[str, Any]: A dictionary containing additional information.</p> required Source code in <code>teleop_xr/__init__.py</code> <pre><code>def subscribe(self, callback: Callable[[np.ndarray, Any], None]) -&gt; None:\n    \"\"\"\n    Subscribe to receive updates from the teleop module.\n\n    Parameters:\n        callback (Callable[[np.ndarray, dict[str, Any]], None]): A callback function that will be called when pose updates are received.\n            The callback function should take two arguments:\n                - np.ndarray: A 4x4 transformation matrix representing the end-effector target pose.\n                - dict[str, Any]: A dictionary containing additional information.\n    \"\"\"\n    self.__callbacks.append(callback)\n</code></pre>"},{"location":"api/#teleop_xr.are_close","title":"<code>are_close(a, b=None, lin_tol=1e-09, ang_tol=1e-09)</code>","text":"<p>Check if two transformation matrices are close to each other within specified tolerances.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>The first transformation matrix.</p> required <code>b</code> <code>ndarray</code> <p>The second transformation matrix. If not provided, it defaults to the identity matrix.</p> <code>None</code> <code>lin_tol</code> <code>float</code> <p>The linear tolerance for closeness. Defaults to 1e-9.</p> <code>1e-09</code> <code>ang_tol</code> <code>float</code> <p>The angular tolerance for closeness. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the matrices are close, False otherwise.</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def are_close(a, b=None, lin_tol=1e-9, ang_tol=1e-9) -&gt; bool:\n    \"\"\"\n    Check if two transformation matrices are close to each other within specified tolerances.\n\n    Parameters:\n        a (numpy.ndarray): The first transformation matrix.\n        b (numpy.ndarray, optional): The second transformation matrix. If not provided, it defaults to the identity matrix.\n        lin_tol (float, optional): The linear tolerance for closeness. Defaults to 1e-9.\n        ang_tol (float, optional): The angular tolerance for closeness. Defaults to 1e-9.\n\n    Returns:\n        bool: True if the matrices are close, False otherwise.\n    \"\"\"\n    if b is None:\n        b = np.eye(4)\n    d = np.linalg.inv(a) @ b\n    if not np.allclose(d[:3, 3], np.zeros(3), atol=lin_tol):\n        return False\n    yaw = math.atan2(d[1, 0], d[0, 0])\n    pitch = math.asin(-d[2, 0])\n    roll = math.atan2(d[2, 1], d[2, 2])\n    rpy = np.array([roll, pitch, yaw])\n    return np.allclose(rpy, np.zeros(3), atol=ang_tol)\n</code></pre>"},{"location":"api/#teleop_xr.interpolate_transforms","title":"<code>interpolate_transforms(T1, T2, alpha)</code>","text":"<p>Interpolate between two 4x4 transformation matrices using SLERP + linear translation.</p> <p>Parameters:</p> Name Type Description Default <code>T1</code> <code>ndarray</code> <p>Start transform (4x4)</p> required <code>T2</code> <code>ndarray</code> <p>End transform (4x4)</p> required <code>alpha</code> <code>float</code> <p>Interpolation factor [0, 1]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Interpolated transform (4x4)</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def interpolate_transforms(T1, T2, alpha) -&gt; np.ndarray:\n    \"\"\"\n    Interpolate between two 4x4 transformation matrices using SLERP + linear translation.\n\n    Args:\n        T1 (np.ndarray): Start transform (4x4)\n        T2 (np.ndarray): End transform (4x4)\n        alpha (float): Interpolation factor [0, 1]\n\n    Returns:\n        np.ndarray: Interpolated transform (4x4)\n    \"\"\"\n    assert T1.shape == (4, 4) and T2.shape == (4, 4)\n    assert 0.0 &lt;= alpha &lt;= 1.0\n\n    # Translation\n    t1 = T1[:3, 3]\n    t2 = T2[:3, 3]\n    t_interp = (1 - alpha) * t1 + alpha * t2\n\n    # Rotation\n    R1 = T1[:3, :3]\n    R2 = T2[:3, :3]\n    q1 = t3d.quaternions.mat2quat(R1)\n    q2 = t3d.quaternions.mat2quat(R2)\n\n    # SLERP\n    q_interp = slerp(q1, q2, alpha)\n    R_interp = t3d.quaternions.quat2mat(q_interp)\n\n    # Final transform\n    T_interp = np.eye(4)\n    T_interp[:3, :3] = R_interp\n    T_interp[:3, 3] = t_interp\n\n    return T_interp\n</code></pre>"},{"location":"api/#teleop_xr.slerp","title":"<code>slerp(q1, q2, t)</code>","text":"<p>Spherical linear interpolation between two quaternions.</p> Source code in <code>teleop_xr/__init__.py</code> <pre><code>def slerp(q1, q2, t) -&gt; np.ndarray:\n    \"\"\"Spherical linear interpolation between two quaternions.\"\"\"\n    q1 = q1 / np.linalg.norm(q1)\n    q2 = q2 / np.linalg.norm(q2)\n\n    dot = np.dot(q1, q2)\n\n    # If the dot product is negative, use the shortest path\n    if dot &lt; 0.0:\n        q2 = -q2\n        dot = -dot\n\n    DOT_THRESHOLD = 0.9995\n    if dot &gt; DOT_THRESHOLD:\n        # Linear interpolation fallback for nearly identical quaternions\n        result = q1 + t * (q2 - q1)\n        return result / np.linalg.norm(result)\n\n    theta_0 = np.arccos(dot)\n    theta = theta_0 * t\n\n    q3 = q2 - q1 * dot\n    q3 = q3 / np.linalg.norm(q3)\n\n    return q1 * np.cos(theta) + q3 * np.sin(theta)\n</code></pre>"},{"location":"api/#teleop_xrconfig","title":"teleop_xr.config","text":""},{"location":"api/#teleop_xr.config","title":"<code>teleop_xr.config</code>","text":""},{"location":"api/#teleop_xrmessages","title":"teleop_xr.messages","text":""},{"location":"api/#teleop_xr.messages","title":"<code>teleop_xr.messages</code>","text":""},{"location":"api/#inverse-kinematics-ik","title":"Inverse Kinematics (IK)","text":""},{"location":"api/#teleop_xrikcontroller","title":"teleop_xr.ik.controller","text":""},{"location":"api/#teleop_xr.ik.controller","title":"<code>teleop_xr.ik.controller</code>","text":""},{"location":"api/#teleop_xr.ik.controller.IKController","title":"<code>IKController</code>","text":"<p>High-level controller for teleoperation using IK.</p> <p>This class manages the transition between idle and active teleoperation, handles XR device snapshots for relative motion, and coordinates between the robot model, IK solver, and optional output filtering.</p> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>class IKController:\n    \"\"\"\n    High-level controller for teleoperation using IK.\n\n    This class manages the transition between idle and active teleoperation,\n    handles XR device snapshots for relative motion, and coordinates between\n    the robot model, IK solver, and optional output filtering.\n    \"\"\"\n\n    robot: BaseRobot\n    solver: PyrokiSolver | None\n    active: bool\n    snapshot_xr: dict[str, jaxlie.SE3]\n    snapshot_robot: dict[str, jaxlie.SE3]\n    filter: WeightedMovingFilter | None\n    _warned_unsupported: set[str]\n\n    def __init__(\n        self,\n        robot: BaseRobot,\n        solver: PyrokiSolver | None = None,\n        filter_weights: np.ndarray | None = None,\n    ):\n        \"\"\"\n        Initialize the IK controller.\n\n        Args:\n            robot: The robot model.\n            solver: The IK solver. If None, step() will return current_config.\n            filter_weights: Optional weights for a WeightedMovingFilter on joint outputs.\n        \"\"\"\n        self.robot = robot\n        self.solver = solver\n        self.active = False\n        self._warned_unsupported = set()\n\n        # Snapshots\n        self.snapshot_xr = {}\n        self.snapshot_robot = {}\n\n        # Filter for joint configuration\n        self.filter = None\n        if filter_weights is not None:\n            # We'll initialize the filter when we know the data size (from default config)\n            default_config = self.robot.get_default_config()\n            self.filter = WeightedMovingFilter(\n                filter_weights, data_size=len(default_config)\n            )\n\n    def xr_pose_to_se3(self, pose: XRPose) -&gt; jaxlie.SE3:\n        \"\"\"\n        Convert an XRPose to a jaxlie SE3 object.\n\n        Args:\n            pose: The XR pose to convert.\n\n        Returns:\n            jaxlie.SE3: The converted pose.\n        \"\"\"\n        translation = jnp.array(\n            [pose.position[\"x\"], pose.position[\"y\"], pose.position[\"z\"]]\n        )\n        rotation = jaxlie.SO3(\n            wxyz=jnp.array(\n                [\n                    pose.orientation[\"w\"],\n                    pose.orientation[\"x\"],\n                    pose.orientation[\"y\"],\n                    pose.orientation[\"z\"],\n                ]\n            )\n        )\n        return jaxlie.SE3.from_rotation_and_translation(rotation, translation)\n\n    def compute_teleop_transform(\n        self, t_ctrl_curr: jaxlie.SE3, t_ctrl_init: jaxlie.SE3, t_ee_init: jaxlie.SE3\n    ) -&gt; jaxlie.SE3:\n        \"\"\"\n        Compute the target robot pose based on XR controller motion.\n\n        Args:\n            t_ctrl_curr: Current XR controller pose.\n            t_ctrl_init: XR controller pose at the start of teleoperation.\n            t_ee_init: Robot end-effector pose at the start of teleoperation.\n\n        Returns:\n            jaxlie.SE3: The calculated target pose for the robot end-effector.\n        \"\"\"\n        t_delta_ros = t_ctrl_curr.translation() - t_ctrl_init.translation()\n        t_delta_robot = self.robot.ros_to_base @ t_delta_ros\n\n        q_delta_ros = t_ctrl_curr.rotation() @ t_ctrl_init.rotation().inverse()\n        q_delta_robot = self.robot.ros_to_base @ q_delta_ros @ self.robot.base_to_ros\n\n        t_new = t_ee_init.translation() + t_delta_robot\n        q_new = q_delta_robot @ t_ee_init.rotation()\n\n        return jaxlie.SE3.from_rotation_and_translation(q_new, t_new)\n\n    def _get_device_poses(self, state: XRState) -&gt; dict[str, jaxlie.SE3]:\n        \"\"\"\n        Extract poses for relevant XR devices from the current state.\n        \"\"\"\n        poses = {}\n        supported = self.robot.supported_frames\n        for device in state.devices:\n            frame_name = None\n            pose_data = None\n            if device.role == XRDeviceRole.CONTROLLER:\n                if device.handedness == XRHandedness.LEFT and device.gripPose:\n                    frame_name = \"left\"\n                    pose_data = device.gripPose\n                elif device.handedness == XRHandedness.RIGHT and device.gripPose:\n                    frame_name = \"right\"\n                    pose_data = device.gripPose\n            elif device.role == XRDeviceRole.HEAD and device.pose:\n                frame_name = \"head\"\n                pose_data = device.pose\n\n            if frame_name and pose_data is not None:\n                if frame_name in supported:\n                    poses[frame_name] = self.xr_pose_to_se3(pose_data)\n                elif frame_name not in self._warned_unsupported:\n                    logger.warning(\n                        f\"[IKController] Warning: Frame '{frame_name}' is available in XRState but not supported by robot. Skipping.\"\n                    )\n                    self._warned_unsupported.add(frame_name)\n        return poses\n\n    def _check_deadman(self, state: XRState) -&gt; bool:\n        \"\"\"\n        Check if the deadman switch (usually trigger or grip) is engaged on both controllers.\n        \"\"\"\n        left_squeezed = False\n        right_squeezed = False\n        for device in state.devices:\n            if device.role == XRDeviceRole.CONTROLLER:\n                is_squeezed = (\n                    device.gamepad is not None\n                    and len(device.gamepad.buttons) &gt; 1\n                    and device.gamepad.buttons[1].pressed\n                )\n                if device.handedness == XRHandedness.LEFT:\n                    left_squeezed = is_squeezed\n                elif device.handedness == XRHandedness.RIGHT:\n                    right_squeezed = is_squeezed\n        return left_squeezed and right_squeezed\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets the controller state, forcing it to re-take snapshots on the next step.\n        \"\"\"\n        self.active = False\n        self.snapshot_xr = {}\n        self.snapshot_robot = {}\n        if self.filter is not None:\n            self.filter.reset()\n        logger.info(\"[IKController] Reset triggered\")\n\n    def step(self, state: XRState, q_current: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Execute one control step: update targets and solve for new joint configuration.\n\n        Args:\n            state: The current XR state from the headset.\n            q_current: The current joint configuration of the robot.\n\n        Returns:\n            np.ndarray: The new (possibly filtered) joint configuration.\n        \"\"\"\n        is_deadman_active = self._check_deadman(state)\n        curr_xr_poses = self._get_device_poses(state)\n\n        # Check if we have all necessary poses\n        required_keys = self.robot.supported_frames\n        has_all_poses = all(k in curr_xr_poses for k in required_keys)\n\n        if is_deadman_active and has_all_poses:\n            if not self.active:\n                # Engagement transition: take snapshots\n                self.active = True\n                self.snapshot_xr = curr_xr_poses\n\n                # Get initial robot FK poses\n                # Cast q_current to jnp.ndarray for JAX-based robot models\n                fk_poses = self.robot.forward_kinematics(jnp.asarray(q_current))\n                self.snapshot_robot = {k: fk_poses[k] for k in required_keys}\n\n                logger.info(f\"[IKController] Initial Robot FK: {self.snapshot_robot}\")\n                return q_current\n\n            # Active control\n            target_L: jaxlie.SE3 | None = None\n            target_R: jaxlie.SE3 | None = None\n            target_Head: jaxlie.SE3 | None = None\n\n            if \"left\" in required_keys:\n                target_L = self.compute_teleop_transform(\n                    curr_xr_poses[\"left\"],\n                    self.snapshot_xr[\"left\"],\n                    self.snapshot_robot[\"left\"],\n                )\n            if \"right\" in required_keys:\n                target_R = self.compute_teleop_transform(\n                    curr_xr_poses[\"right\"],\n                    self.snapshot_xr[\"right\"],\n                    self.snapshot_robot[\"right\"],\n                )\n            if \"head\" in required_keys:\n                target_Head = self.compute_teleop_transform(\n                    curr_xr_poses[\"head\"],\n                    self.snapshot_xr[\"head\"],\n                    self.snapshot_robot[\"head\"],\n                )\n\n            if self.solver is not None:\n                # Solve for new configuration using target poses and current config\n                # Cast inputs to JAX arrays and output back to numpy\n                new_config_jax = self.solver.solve(\n                    target_L,\n                    target_R,\n                    target_Head,\n                    jnp.asarray(q_current),\n                )\n                new_config = np.array(new_config_jax)\n\n                if self.filter is not None:\n                    self.filter.add_data(new_config)\n                    if self.filter.data_ready():\n                        return self.filter.filtered_data\n\n                logger.debug(f\"[IKController] New Config: {new_config}\")\n                return new_config\n\n            return q_current\n        else:\n            if self.active:\n                # Disengagement transition\n                self.active = False\n                if self.filter is not None:\n                    self.filter.reset()\n            return q_current\n</code></pre>"},{"location":"api/#teleop_xr.ik.controller.IKController.__init__","title":"<code>__init__(robot, solver=None, filter_weights=None)</code>","text":"<p>Initialize the IK controller.</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>BaseRobot</code> <p>The robot model.</p> required <code>solver</code> <code>PyrokiSolver | None</code> <p>The IK solver. If None, step() will return current_config.</p> <code>None</code> <code>filter_weights</code> <code>ndarray | None</code> <p>Optional weights for a WeightedMovingFilter on joint outputs.</p> <code>None</code> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>def __init__(\n    self,\n    robot: BaseRobot,\n    solver: PyrokiSolver | None = None,\n    filter_weights: np.ndarray | None = None,\n):\n    \"\"\"\n    Initialize the IK controller.\n\n    Args:\n        robot: The robot model.\n        solver: The IK solver. If None, step() will return current_config.\n        filter_weights: Optional weights for a WeightedMovingFilter on joint outputs.\n    \"\"\"\n    self.robot = robot\n    self.solver = solver\n    self.active = False\n    self._warned_unsupported = set()\n\n    # Snapshots\n    self.snapshot_xr = {}\n    self.snapshot_robot = {}\n\n    # Filter for joint configuration\n    self.filter = None\n    if filter_weights is not None:\n        # We'll initialize the filter when we know the data size (from default config)\n        default_config = self.robot.get_default_config()\n        self.filter = WeightedMovingFilter(\n            filter_weights, data_size=len(default_config)\n        )\n</code></pre>"},{"location":"api/#teleop_xr.ik.controller.IKController.compute_teleop_transform","title":"<code>compute_teleop_transform(t_ctrl_curr, t_ctrl_init, t_ee_init)</code>","text":"<p>Compute the target robot pose based on XR controller motion.</p> <p>Parameters:</p> Name Type Description Default <code>t_ctrl_curr</code> <code>SE3</code> <p>Current XR controller pose.</p> required <code>t_ctrl_init</code> <code>SE3</code> <p>XR controller pose at the start of teleoperation.</p> required <code>t_ee_init</code> <code>SE3</code> <p>Robot end-effector pose at the start of teleoperation.</p> required <p>Returns:</p> Type Description <code>SE3</code> <p>jaxlie.SE3: The calculated target pose for the robot end-effector.</p> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>def compute_teleop_transform(\n    self, t_ctrl_curr: jaxlie.SE3, t_ctrl_init: jaxlie.SE3, t_ee_init: jaxlie.SE3\n) -&gt; jaxlie.SE3:\n    \"\"\"\n    Compute the target robot pose based on XR controller motion.\n\n    Args:\n        t_ctrl_curr: Current XR controller pose.\n        t_ctrl_init: XR controller pose at the start of teleoperation.\n        t_ee_init: Robot end-effector pose at the start of teleoperation.\n\n    Returns:\n        jaxlie.SE3: The calculated target pose for the robot end-effector.\n    \"\"\"\n    t_delta_ros = t_ctrl_curr.translation() - t_ctrl_init.translation()\n    t_delta_robot = self.robot.ros_to_base @ t_delta_ros\n\n    q_delta_ros = t_ctrl_curr.rotation() @ t_ctrl_init.rotation().inverse()\n    q_delta_robot = self.robot.ros_to_base @ q_delta_ros @ self.robot.base_to_ros\n\n    t_new = t_ee_init.translation() + t_delta_robot\n    q_new = q_delta_robot @ t_ee_init.rotation()\n\n    return jaxlie.SE3.from_rotation_and_translation(q_new, t_new)\n</code></pre>"},{"location":"api/#teleop_xr.ik.controller.IKController.reset","title":"<code>reset()</code>","text":"<p>Resets the controller state, forcing it to re-take snapshots on the next step.</p> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets the controller state, forcing it to re-take snapshots on the next step.\n    \"\"\"\n    self.active = False\n    self.snapshot_xr = {}\n    self.snapshot_robot = {}\n    if self.filter is not None:\n        self.filter.reset()\n    logger.info(\"[IKController] Reset triggered\")\n</code></pre>"},{"location":"api/#teleop_xr.ik.controller.IKController.step","title":"<code>step(state, q_current)</code>","text":"<p>Execute one control step: update targets and solve for new joint configuration.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>XRState</code> <p>The current XR state from the headset.</p> required <code>q_current</code> <code>ndarray</code> <p>The current joint configuration of the robot.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The new (possibly filtered) joint configuration.</p> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>def step(self, state: XRState, q_current: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Execute one control step: update targets and solve for new joint configuration.\n\n    Args:\n        state: The current XR state from the headset.\n        q_current: The current joint configuration of the robot.\n\n    Returns:\n        np.ndarray: The new (possibly filtered) joint configuration.\n    \"\"\"\n    is_deadman_active = self._check_deadman(state)\n    curr_xr_poses = self._get_device_poses(state)\n\n    # Check if we have all necessary poses\n    required_keys = self.robot.supported_frames\n    has_all_poses = all(k in curr_xr_poses for k in required_keys)\n\n    if is_deadman_active and has_all_poses:\n        if not self.active:\n            # Engagement transition: take snapshots\n            self.active = True\n            self.snapshot_xr = curr_xr_poses\n\n            # Get initial robot FK poses\n            # Cast q_current to jnp.ndarray for JAX-based robot models\n            fk_poses = self.robot.forward_kinematics(jnp.asarray(q_current))\n            self.snapshot_robot = {k: fk_poses[k] for k in required_keys}\n\n            logger.info(f\"[IKController] Initial Robot FK: {self.snapshot_robot}\")\n            return q_current\n\n        # Active control\n        target_L: jaxlie.SE3 | None = None\n        target_R: jaxlie.SE3 | None = None\n        target_Head: jaxlie.SE3 | None = None\n\n        if \"left\" in required_keys:\n            target_L = self.compute_teleop_transform(\n                curr_xr_poses[\"left\"],\n                self.snapshot_xr[\"left\"],\n                self.snapshot_robot[\"left\"],\n            )\n        if \"right\" in required_keys:\n            target_R = self.compute_teleop_transform(\n                curr_xr_poses[\"right\"],\n                self.snapshot_xr[\"right\"],\n                self.snapshot_robot[\"right\"],\n            )\n        if \"head\" in required_keys:\n            target_Head = self.compute_teleop_transform(\n                curr_xr_poses[\"head\"],\n                self.snapshot_xr[\"head\"],\n                self.snapshot_robot[\"head\"],\n            )\n\n        if self.solver is not None:\n            # Solve for new configuration using target poses and current config\n            # Cast inputs to JAX arrays and output back to numpy\n            new_config_jax = self.solver.solve(\n                target_L,\n                target_R,\n                target_Head,\n                jnp.asarray(q_current),\n            )\n            new_config = np.array(new_config_jax)\n\n            if self.filter is not None:\n                self.filter.add_data(new_config)\n                if self.filter.data_ready():\n                    return self.filter.filtered_data\n\n            logger.debug(f\"[IKController] New Config: {new_config}\")\n            return new_config\n\n        return q_current\n    else:\n        if self.active:\n            # Disengagement transition\n            self.active = False\n            if self.filter is not None:\n                self.filter.reset()\n        return q_current\n</code></pre>"},{"location":"api/#teleop_xr.ik.controller.IKController.xr_pose_to_se3","title":"<code>xr_pose_to_se3(pose)</code>","text":"<p>Convert an XRPose to a jaxlie SE3 object.</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>XRPose</code> <p>The XR pose to convert.</p> required <p>Returns:</p> Type Description <code>SE3</code> <p>jaxlie.SE3: The converted pose.</p> Source code in <code>teleop_xr/ik/controller.py</code> <pre><code>def xr_pose_to_se3(self, pose: XRPose) -&gt; jaxlie.SE3:\n    \"\"\"\n    Convert an XRPose to a jaxlie SE3 object.\n\n    Args:\n        pose: The XR pose to convert.\n\n    Returns:\n        jaxlie.SE3: The converted pose.\n    \"\"\"\n    translation = jnp.array(\n        [pose.position[\"x\"], pose.position[\"y\"], pose.position[\"z\"]]\n    )\n    rotation = jaxlie.SO3(\n        wxyz=jnp.array(\n            [\n                pose.orientation[\"w\"],\n                pose.orientation[\"x\"],\n                pose.orientation[\"y\"],\n                pose.orientation[\"z\"],\n            ]\n        )\n    )\n    return jaxlie.SE3.from_rotation_and_translation(rotation, translation)\n</code></pre>"},{"location":"api/#teleop_xriksolver","title":"teleop_xr.ik.solver","text":""},{"location":"api/#teleop_xr.ik.solver","title":"<code>teleop_xr.ik.solver</code>","text":""},{"location":"api/#teleop_xr.ik.solver.PyrokiSolver","title":"<code>PyrokiSolver</code>","text":"<p>Inverse Kinematics (IK) solver using Pyroki and jaxls.</p> <p>This solver uses optimization (Least Squares) to find joint configurations that satisfy target poses for the robot's end-effectors and head. It leverages JAX for high-performance, JIT-compiled solving.</p> Source code in <code>teleop_xr/ik/solver.py</code> <pre><code>class PyrokiSolver:\n    \"\"\"\n    Inverse Kinematics (IK) solver using Pyroki and jaxls.\n\n    This solver uses optimization (Least Squares) to find joint configurations\n    that satisfy target poses for the robot's end-effectors and head.\n    It leverages JAX for high-performance, JIT-compiled solving.\n    \"\"\"\n\n    robot: BaseRobot\n    _jit_solve: Callable[\n        [jaxlie.SE3 | None, jaxlie.SE3 | None, jaxlie.SE3 | None, jnp.ndarray],\n        jnp.ndarray,\n    ]\n    warmup_complete: bool\n    warmup_error: str | None\n    warmed_target_patterns: tuple[tuple[bool, bool, bool], ...]\n\n    def __init__(self, robot: BaseRobot):\n        \"\"\"\n        Initialize the solver with a robot model.\n\n        Args:\n            robot: The robot model providing kinematic info and costs.\n        \"\"\"\n        self.robot = robot\n        self.warmup_complete = False\n        self.warmup_error = None\n        self.warmed_target_patterns = tuple()\n\n        # JIT compile the solve function\n        self._jit_solve = jax.jit(self._solve_internal)\n\n        # Warmup to trigger JIT compilation\n        self._warmup()\n\n    def _solve_internal(\n        self,\n        target_L: jaxlie.SE3 | None,\n        target_R: jaxlie.SE3 | None,\n        target_Head: jaxlie.SE3 | None,\n        q_current: jnp.ndarray,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Internal solve function that will be JIT-compiled.\n\n        Args:\n            target_L: Target pose for the left end-effector.\n            target_R: Target pose for the right end-effector.\n            target_Head: Target pose for the head.\n            q_current: Current joint configuration (initial guess).\n\n        Returns:\n            jnp.ndarray: Optimized joint configuration.\n        \"\"\"\n        # 1. Build costs from the robot\n        costs = self.robot.build_costs(target_L, target_R, target_Head, q_current)\n\n        # 2. Get the joint variable (assuming single timestep index 0)\n        # The robot is expected to have joint_var_cls.\n        # We use a single timestep for standard IK.\n        var_joints = self.robot.joint_var_cls(jnp.array([0]))\n\n        # 3. Construct initial values\n        # q_current is expected to be (num_joints,)\n        # Variable values usually expect (timesteps, joint_dims)\n        initial_vals = jaxls.VarValues.make(\n            [var_joints.with_value(q_current[jnp.newaxis, :])]\n        )\n\n        # 4. Construct and solve the LeastSquaresProblem\n        # We optimize over joint variables.\n        # Note: If the robot defines more variables in costs, they should be added here.\n        # For a generic solver, we assume joint variables are the primary optimization targets.\n        problem = jaxls.LeastSquaresProblem(costs, [var_joints])\n\n        # solve() returns a VarValues object containing the solution\n        solution = problem.analyze().solve(\n            initial_vals=initial_vals,\n            verbose=False,\n            linear_solver=\"dense_cholesky\",\n            termination=jaxls.TerminationConfig(max_iterations=15),\n        )\n\n        # Return the optimized joint configuration for the first (and only) timestep\n        return solution[var_joints][0]\n\n    def solve(\n        self,\n        target_L: jaxlie.SE3 | None,\n        target_R: jaxlie.SE3 | None,\n        target_Head: jaxlie.SE3 | None,\n        q_current: jnp.ndarray,\n    ) -&gt; jnp.ndarray:\n        \"\"\"\n        Solve the IK problem for the given targets and current configuration.\n\n        Args:\n            target_L: Target pose for the left end-effector.\n            target_R: Target pose for the right end-effector.\n            target_Head: Target pose for the head.\n            q_current: Current joint configuration (initial guess).\n\n        Returns:\n            jnp.ndarray: Optimized joint configuration.\n        \"\"\"\n        return self._jit_solve(target_L, target_R, target_Head, q_current)\n\n    def _warmup(self) -&gt; None:\n        \"\"\"\n        Triggers JIT compilation by running a solve with dummy data.\n        \"\"\"\n        try:\n            q_dummy = self.robot.get_default_config()\n            target_dummy = jaxlie.SE3.identity()\n\n            warmup_inputs = (\n                (target_dummy, target_dummy, target_dummy),\n                (target_dummy, None, None),\n                (None, target_dummy, None),\n                (None, None, target_dummy),\n                (target_dummy, target_dummy, None),\n                (target_dummy, None, target_dummy),\n                (None, target_dummy, target_dummy),\n                (None, None, None),\n            )\n\n            for target_L, target_R, target_Head in warmup_inputs:\n                warmed = self.solve(target_L, target_R, target_Head, q_dummy)\n                jax.block_until_ready(warmed)\n\n            self.warmed_target_patterns = tuple(\n                (\n                    target_L is not None,\n                    target_R is not None,\n                    target_Head is not None,\n                )\n                for target_L, target_R, target_Head in warmup_inputs\n            )\n            self.warmup_complete = True\n            self.warmup_error = None\n        except Exception as exc:\n            # Warmup might fail if robot is a mock or not fully implemented yet.\n            # Keep initialization resilient, but expose failure explicitly.\n            self.warmup_complete = False\n            self.warmup_error = str(exc)\n            self.warmed_target_patterns = tuple()\n            logger.warning(f\"[PyrokiSolver] Warmup failed: {exc}\")\n</code></pre>"},{"location":"api/#teleop_xr.ik.solver.PyrokiSolver.__init__","title":"<code>__init__(robot)</code>","text":"<p>Initialize the solver with a robot model.</p> <p>Parameters:</p> Name Type Description Default <code>robot</code> <code>BaseRobot</code> <p>The robot model providing kinematic info and costs.</p> required Source code in <code>teleop_xr/ik/solver.py</code> <pre><code>def __init__(self, robot: BaseRobot):\n    \"\"\"\n    Initialize the solver with a robot model.\n\n    Args:\n        robot: The robot model providing kinematic info and costs.\n    \"\"\"\n    self.robot = robot\n    self.warmup_complete = False\n    self.warmup_error = None\n    self.warmed_target_patterns = tuple()\n\n    # JIT compile the solve function\n    self._jit_solve = jax.jit(self._solve_internal)\n\n    # Warmup to trigger JIT compilation\n    self._warmup()\n</code></pre>"},{"location":"api/#teleop_xr.ik.solver.PyrokiSolver.solve","title":"<code>solve(target_L, target_R, target_Head, q_current)</code>","text":"<p>Solve the IK problem for the given targets and current configuration.</p> <p>Parameters:</p> Name Type Description Default <code>target_L</code> <code>SE3 | None</code> <p>Target pose for the left end-effector.</p> required <code>target_R</code> <code>SE3 | None</code> <p>Target pose for the right end-effector.</p> required <code>target_Head</code> <code>SE3 | None</code> <p>Target pose for the head.</p> required <code>q_current</code> <code>ndarray</code> <p>Current joint configuration (initial guess).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: Optimized joint configuration.</p> Source code in <code>teleop_xr/ik/solver.py</code> <pre><code>def solve(\n    self,\n    target_L: jaxlie.SE3 | None,\n    target_R: jaxlie.SE3 | None,\n    target_Head: jaxlie.SE3 | None,\n    q_current: jnp.ndarray,\n) -&gt; jnp.ndarray:\n    \"\"\"\n    Solve the IK problem for the given targets and current configuration.\n\n    Args:\n        target_L: Target pose for the left end-effector.\n        target_R: Target pose for the right end-effector.\n        target_Head: Target pose for the head.\n        q_current: Current joint configuration (initial guess).\n\n    Returns:\n        jnp.ndarray: Optimized joint configuration.\n    \"\"\"\n    return self._jit_solve(target_L, target_R, target_Head, q_current)\n</code></pre>"},{"location":"api/#teleop_xrikrobot","title":"teleop_xr.ik.robot","text":""},{"location":"api/#teleop_xr.ik.robot","title":"<code>teleop_xr.ik.robot</code>","text":""},{"location":"api/#teleop_xr.ik.robot.BaseRobot","title":"<code>BaseRobot</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for robot models used in IK optimization.</p> <p>This class defines the interface required by the IK solver and controller to compute kinematics and optimization costs.</p> Source code in <code>teleop_xr/ik/robot.py</code> <pre><code>class BaseRobot(ABC):\n    \"\"\"\n    Abstract base class for robot models used in IK optimization.\n\n    This class defines the interface required by the IK solver and controller\n    to compute kinematics and optimization costs.\n    \"\"\"\n\n    def __init__(self):\n        self.urdf_path: str = \"\"\n        self.mesh_path: str | None = None\n\n    @property\n    def orientation(self) -&gt; jaxlie.SO3:\n        \"\"\"\n        Rotation from the robot's base frame to the canonical ROS2 frame (X-forward, Z-up).\n        \"\"\"\n        return jaxlie.SO3.identity()\n\n    @property\n    def base_to_ros(self) -&gt; jaxlie.SO3:\n        \"\"\"Rotation from the robot base frame to the canonical ROS2 frame.\"\"\"\n        return self.orientation\n\n    @property\n    def ros_to_base(self) -&gt; jaxlie.SO3:\n        \"\"\"Rotation from the canonical ROS2 frame to the robot base frame.\"\"\"\n        return self.orientation.inverse()\n\n    @property\n    def model_scale(self) -&gt; float:\n        \"\"\"\n        Get the model scale for visualization.\n        \"\"\"\n        return 1.0\n\n    def get_vis_config(self) -&gt; RobotVisConfig | None:\n        \"\"\"\n        Get the visualization configuration for this robot.\n\n        Returns:\n            RobotVisConfig | None: Configuration for rendering the robot, or None if not supported.\n\n        Note:\n            Subclasses should use `self.orientation` to populate\n            `RobotVisConfig.initial_rotation_euler`.\n        \"\"\"\n        if not self.urdf_path:\n            return None\n        return RobotVisConfig(\n            urdf_path=self.urdf_path,\n            mesh_path=self.mesh_path,\n            model_scale=self.model_scale,\n            initial_rotation_euler=[\n                float(x) for x in self.orientation.as_rpy_radians()\n            ],\n        )\n\n    @abstractmethod\n    def _load_default_urdf(self) -&gt; Any:\n        \"\"\"\n        Load the default URDF for this robot.\n\n        Returns:\n            yourdfpy.URDF: The loaded URDF object.\n        \"\"\"\n        pass  # pragma: no cover\n\n    def _load_urdf(self, urdf_string: str | None = None) -&gt; Any:\n        \"\"\"\n        Load a URDF from a string or from the default location.\n\n        Args:\n            urdf_string: Optional URDF XML string. If provided, it overrides the default URDF.\n\n        Returns:\n            yourdfpy.URDF: The loaded URDF object.\n        \"\"\"\n        import yourdfpy\n        from teleop_xr import ram\n\n        if urdf_string is not None:\n            path, mesh = ram.from_string(urdf_string)\n            self.urdf_path = str(path)\n            self.mesh_path = mesh\n            return yourdfpy.URDF.load(self.urdf_path)\n\n        return self._load_default_urdf()\n\n    @property\n    @abstractmethod\n    def actuated_joint_names(self) -&gt; list[str]:\n        \"\"\"\n        Get the names of the actuated joints.\n\n        Returns:\n            list[str]: A list of joint names.\n        \"\"\"\n        pass  # pragma: no cover\n\n    @property\n    @abstractmethod\n    def joint_var_cls(self) -&gt; Any:\n        \"\"\"\n        The jaxls.Var class used for joint configurations.\n\n        Returns:\n            Type[jaxls.Var]: The variable class to use for optimization.\n        \"\"\"\n        pass  # pragma: no cover\n\n    @property\n    def supported_frames(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of supported frames for this robot.\n\n        Returns:\n            set[str]: A set of frame names (e.g., {\"left\", \"right\", \"head\"}).\n        \"\"\"\n        return {\"left\", \"right\", \"head\"}\n\n    @property\n    def default_speed_ratio(self) -&gt; float:\n        \"\"\"\n        Get the default teleop speed ratio for this robot.\n\n        Returns:\n            float: The default speed ratio (e.g., 1.0 for 100%, 1.2 for 120%).\n        \"\"\"\n        return 1.0\n\n    @abstractmethod\n    def forward_kinematics(self, config: jnp.ndarray) -&gt; dict[str, jaxlie.SE3]:\n        \"\"\"\n        Compute the forward kinematics for the given configuration.\n\n        Args:\n            config: The robot configuration (e.g., joint angles) as a JAX array.\n\n        Returns:\n            dict[str, jaxlie.SE3]: A dictionary mapping link names (e.g., \"left\", \"right\", \"head\")\n                                  to their respective SE3 poses.\n        \"\"\"\n        pass  # pragma: no cover\n\n    @abstractmethod\n    def get_default_config(self) -&gt; jnp.ndarray:\n        \"\"\"\n        Get the default configuration for the robot.\n\n        Returns:\n            jnp.ndarray: The default configuration as a JAX array.\n        \"\"\"\n        pass  # pragma: no cover\n\n    @abstractmethod\n    def build_costs(\n        self,\n        target_L: jaxlie.SE3 | None,\n        target_R: jaxlie.SE3 | None,\n        target_Head: jaxlie.SE3 | None,\n        q_current: jnp.ndarray | None = None,\n    ) -&gt; list[Cost]:\n        \"\"\"\n        Build a list of costs for the robot-specific formulation.\n\n        Args:\n            target_L: Target pose for the left end-effector.\n            target_R: Target pose for the right end-effector.\n            target_Head: Target pose for the head.\n            q_current: Current joint configuration (initial guess).\n\n        Returns:\n            list[Cost]: A list of jaxls Cost objects representing the optimization objectives.\n        \"\"\"\n        pass  # pragma: no cover\n</code></pre>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.actuated_joint_names","title":"<code>actuated_joint_names</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the names of the actuated joints.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of joint names.</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.base_to_ros","title":"<code>base_to_ros</code>  <code>property</code>","text":"<p>Rotation from the robot base frame to the canonical ROS2 frame.</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.default_speed_ratio","title":"<code>default_speed_ratio</code>  <code>property</code>","text":"<p>Get the default teleop speed ratio for this robot.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The default speed ratio (e.g., 1.0 for 100%, 1.2 for 120%).</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.joint_var_cls","title":"<code>joint_var_cls</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The jaxls.Var class used for joint configurations.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Type[jaxls.Var]: The variable class to use for optimization.</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.model_scale","title":"<code>model_scale</code>  <code>property</code>","text":"<p>Get the model scale for visualization.</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.orientation","title":"<code>orientation</code>  <code>property</code>","text":"<p>Rotation from the robot's base frame to the canonical ROS2 frame (X-forward, Z-up).</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.ros_to_base","title":"<code>ros_to_base</code>  <code>property</code>","text":"<p>Rotation from the canonical ROS2 frame to the robot base frame.</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.supported_frames","title":"<code>supported_frames</code>  <code>property</code>","text":"<p>Get the set of supported frames for this robot.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: A set of frame names (e.g., {\"left\", \"right\", \"head\"}).</p>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.build_costs","title":"<code>build_costs(target_L, target_R, target_Head, q_current=None)</code>  <code>abstractmethod</code>","text":"<p>Build a list of costs for the robot-specific formulation.</p> <p>Parameters:</p> Name Type Description Default <code>target_L</code> <code>SE3 | None</code> <p>Target pose for the left end-effector.</p> required <code>target_R</code> <code>SE3 | None</code> <p>Target pose for the right end-effector.</p> required <code>target_Head</code> <code>SE3 | None</code> <p>Target pose for the head.</p> required <code>q_current</code> <code>ndarray | None</code> <p>Current joint configuration (initial guess).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Cost]</code> <p>list[Cost]: A list of jaxls Cost objects representing the optimization objectives.</p> Source code in <code>teleop_xr/ik/robot.py</code> <pre><code>@abstractmethod\ndef build_costs(\n    self,\n    target_L: jaxlie.SE3 | None,\n    target_R: jaxlie.SE3 | None,\n    target_Head: jaxlie.SE3 | None,\n    q_current: jnp.ndarray | None = None,\n) -&gt; list[Cost]:\n    \"\"\"\n    Build a list of costs for the robot-specific formulation.\n\n    Args:\n        target_L: Target pose for the left end-effector.\n        target_R: Target pose for the right end-effector.\n        target_Head: Target pose for the head.\n        q_current: Current joint configuration (initial guess).\n\n    Returns:\n        list[Cost]: A list of jaxls Cost objects representing the optimization objectives.\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.forward_kinematics","title":"<code>forward_kinematics(config)</code>  <code>abstractmethod</code>","text":"<p>Compute the forward kinematics for the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ndarray</code> <p>The robot configuration (e.g., joint angles) as a JAX array.</p> required <p>Returns:</p> Type Description <code>dict[str, SE3]</code> <p>dict[str, jaxlie.SE3]: A dictionary mapping link names (e.g., \"left\", \"right\", \"head\")                   to their respective SE3 poses.</p> Source code in <code>teleop_xr/ik/robot.py</code> <pre><code>@abstractmethod\ndef forward_kinematics(self, config: jnp.ndarray) -&gt; dict[str, jaxlie.SE3]:\n    \"\"\"\n    Compute the forward kinematics for the given configuration.\n\n    Args:\n        config: The robot configuration (e.g., joint angles) as a JAX array.\n\n    Returns:\n        dict[str, jaxlie.SE3]: A dictionary mapping link names (e.g., \"left\", \"right\", \"head\")\n                              to their respective SE3 poses.\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.get_default_config","title":"<code>get_default_config()</code>  <code>abstractmethod</code>","text":"<p>Get the default configuration for the robot.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: The default configuration as a JAX array.</p> Source code in <code>teleop_xr/ik/robot.py</code> <pre><code>@abstractmethod\ndef get_default_config(self) -&gt; jnp.ndarray:\n    \"\"\"\n    Get the default configuration for the robot.\n\n    Returns:\n        jnp.ndarray: The default configuration as a JAX array.\n    \"\"\"\n    pass  # pragma: no cover\n</code></pre>"},{"location":"api/#teleop_xr.ik.robot.BaseRobot.get_vis_config","title":"<code>get_vis_config()</code>","text":"<p>Get the visualization configuration for this robot.</p> <p>Returns:</p> Type Description <code>RobotVisConfig | None</code> <p>RobotVisConfig | None: Configuration for rendering the robot, or None if not supported.</p> Note <p>Subclasses should use <code>self.orientation</code> to populate <code>RobotVisConfig.initial_rotation_euler</code>.</p> Source code in <code>teleop_xr/ik/robot.py</code> <pre><code>def get_vis_config(self) -&gt; RobotVisConfig | None:\n    \"\"\"\n    Get the visualization configuration for this robot.\n\n    Returns:\n        RobotVisConfig | None: Configuration for rendering the robot, or None if not supported.\n\n    Note:\n        Subclasses should use `self.orientation` to populate\n        `RobotVisConfig.initial_rotation_euler`.\n    \"\"\"\n    if not self.urdf_path:\n        return None\n    return RobotVisConfig(\n        urdf_path=self.urdf_path,\n        mesh_path=self.mesh_path,\n        model_scale=self.model_scale,\n        initial_rotation_euler=[\n            float(x) for x in self.orientation.as_rpy_radians()\n        ],\n    )\n</code></pre>"},{"location":"api/#teleop_xrikrobotsh1_2","title":"teleop_xr.ik.robots.h1_2","text":""},{"location":"api/#teleop_xr.ik.robots.h1_2","title":"<code>teleop_xr.ik.robots.h1_2</code>","text":""},{"location":"api/#teleop_xr.ik.robots.h1_2.UnitreeH1Robot","title":"<code>UnitreeH1Robot</code>","text":"<p>               Bases: <code>BaseRobot</code></p> <p>Unitree H1_2 robot implementation for IK.</p> Source code in <code>teleop_xr/ik/robots/h1_2.py</code> <pre><code>class UnitreeH1Robot(BaseRobot):\n    \"\"\"\n    Unitree H1_2 robot implementation for IK.\n    \"\"\"\n\n    def __init__(self, urdf_string: str | None = None, **kwargs: Any) -&gt; None:\n        super().__init__()\n        urdf = self._load_urdf(urdf_string)\n\n        # Identify leg joints names to freeze\n        self.leg_joint_names = [\n            \"left_hip_yaw_joint\",\n            \"left_hip_pitch_joint\",\n            \"left_hip_roll_joint\",\n            \"left_knee_joint\",\n            \"left_ankle_pitch_joint\",\n            \"left_ankle_roll_joint\",\n            \"right_hip_yaw_joint\",\n            \"right_hip_pitch_joint\",\n            \"right_hip_roll_joint\",\n            \"right_knee_joint\",\n            \"right_ankle_pitch_joint\",\n            \"right_ankle_roll_joint\",\n        ]\n\n        for joint_name in self.leg_joint_names:\n            if joint_name in urdf.joint_map:\n                urdf.joint_map[joint_name].type = \"fixed\"\n\n        self.robot = pk.Robot.from_urdf(urdf)\n        self.robot_coll = pk.collision.RobotCollision.from_urdf(urdf)\n\n        # End effector and torso link indices\n        # We use hand base links as end effectors (L_ee, R_ee frames)\n        self.L_ee = \"L_hand_base_link\"\n        self.R_ee = \"R_hand_base_link\"\n        self.L_ee_link_idx = self.robot.links.names.index(self.L_ee)\n        self.R_ee_link_idx = self.robot.links.names.index(self.R_ee)\n        self.torso_link_idx = self.robot.links.names.index(\"torso_link\")\n\n    def _load_default_urdf(self) -&gt; yourdfpy.URDF:\n        # Load URDF from external repository via RAM\n        self.urdf_path = str(\n            ram.get_resource(\n                repo_url=\"https://github.com/unitreerobotics/xr_teleoperate.git\",\n                path_inside_repo=\"assets/h1_2/h1_2.urdf\",\n            )\n        )\n        self.mesh_path = os.path.dirname(self.urdf_path)\n        return yourdfpy.URDF.load(self.urdf_path)\n\n    @property\n    @override\n    def model_scale(self) -&gt; float:\n        return 0.5\n\n    @property\n    @override\n    def orientation(self) -&gt; jaxlie.SO3:\n        return jaxlie.SO3.identity()\n\n    @property\n    @override\n    def joint_var_cls(self) -&gt; Any:\n        \"\"\"\n        The jaxls.Var class used for joint configurations.\n        \"\"\"\n        return self.robot.joint_var_cls\n\n    @property\n    @override\n    def actuated_joint_names(self) -&gt; list[str]:\n        return list(self.robot.joints.actuated_names)\n\n    @property\n    def default_speed_ratio(self) -&gt; float:\n        # Unitree H1 often benefits from slightly amplified motion mapping\n        return 1.2\n\n    @override\n    def forward_kinematics(self, config: jax.Array) -&gt; dict[str, jaxlie.SE3]:\n        \"\"\"\n        Compute the forward kinematics for the given configuration.\n        \"\"\"\n        fk = self.robot.forward_kinematics(config)\n        return {\n            \"left\": jaxlie.SE3(fk[self.L_ee_link_idx]),\n            \"right\": jaxlie.SE3(fk[self.R_ee_link_idx]),\n            \"head\": jaxlie.SE3(fk[self.torso_link_idx]),\n        }\n\n    @override\n    def get_default_config(self) -&gt; jax.Array:\n        return jnp.zeros_like(self.robot.joints.lower_limits)\n\n    @override\n    def build_costs(\n        self,\n        target_L: jaxlie.SE3 | None,\n        target_R: jaxlie.SE3 | None,\n        target_Head: jaxlie.SE3 | None,\n        q_current: jnp.ndarray | None = None,\n    ) -&gt; list[Cost]:\n        \"\"\"\n        Build a list of Pyroki cost objects.\n        \"\"\"\n        costs = []\n        JointVar = self.robot.joint_var_cls\n\n        if q_current is not None:\n            costs.append(\n                pk.costs.rest_cost(\n                    JointVar(0),\n                    rest_pose=q_current,\n                    weight=5.0,\n                )\n            )\n\n        costs.append(\n            pk.costs.manipulability_cost(\n                self.robot,\n                JointVar(0),\n                jnp.array([self.L_ee_link_idx, self.R_ee_link_idx], dtype=jnp.int32),\n                weight=0.01,\n            )\n        )\n\n        # 1. Bimanual costs (L/R EE frames: L_ee, R_ee)\n        # Using analytic jacobian for efficiency\n        if target_L is not None:\n            costs.append(\n                pk.costs.pose_cost_analytic_jac(\n                    self.robot,\n                    JointVar(0),\n                    target_L,\n                    jnp.array(self.L_ee_link_idx, dtype=jnp.int32),\n                    pos_weight=50.0,\n                    ori_weight=10.0,\n                )\n            )\n\n        if target_R is not None:\n            costs.append(\n                pk.costs.pose_cost_analytic_jac(\n                    self.robot,\n                    JointVar(0),\n                    target_R,\n                    jnp.array(self.R_ee_link_idx, dtype=jnp.int32),\n                    pos_weight=50.0,\n                    ori_weight=10.0,\n                )\n            )\n\n        costs.append(\n            pk.costs.limit_cost(  # pyright: ignore[reportCallIssue]\n                self.robot, JointVar(0), weight=100.0\n            )\n        )\n\n        if target_Head is not None:\n            costs.append(\n                pk.costs.pose_cost(  # pyright: ignore[reportCallIssue]\n                    robot=self.robot,\n                    joint_var=JointVar(0),\n                    target_pose=target_Head,\n                    target_link_index=jnp.array(self.torso_link_idx, dtype=jnp.int32),\n                    pos_weight=0.0,\n                    ori_weight=jnp.array([0.0, 0.0, 20.0]),\n                )\n            )\n\n        return costs\n</code></pre>"},{"location":"api/#teleop_xr.ik.robots.h1_2.UnitreeH1Robot.joint_var_cls","title":"<code>joint_var_cls</code>  <code>property</code>","text":"<p>The jaxls.Var class used for joint configurations.</p>"},{"location":"api/#teleop_xr.ik.robots.h1_2.UnitreeH1Robot.build_costs","title":"<code>build_costs(target_L, target_R, target_Head, q_current=None)</code>","text":"<p>Build a list of Pyroki cost objects.</p> Source code in <code>teleop_xr/ik/robots/h1_2.py</code> <pre><code>@override\ndef build_costs(\n    self,\n    target_L: jaxlie.SE3 | None,\n    target_R: jaxlie.SE3 | None,\n    target_Head: jaxlie.SE3 | None,\n    q_current: jnp.ndarray | None = None,\n) -&gt; list[Cost]:\n    \"\"\"\n    Build a list of Pyroki cost objects.\n    \"\"\"\n    costs = []\n    JointVar = self.robot.joint_var_cls\n\n    if q_current is not None:\n        costs.append(\n            pk.costs.rest_cost(\n                JointVar(0),\n                rest_pose=q_current,\n                weight=5.0,\n            )\n        )\n\n    costs.append(\n        pk.costs.manipulability_cost(\n            self.robot,\n            JointVar(0),\n            jnp.array([self.L_ee_link_idx, self.R_ee_link_idx], dtype=jnp.int32),\n            weight=0.01,\n        )\n    )\n\n    # 1. Bimanual costs (L/R EE frames: L_ee, R_ee)\n    # Using analytic jacobian for efficiency\n    if target_L is not None:\n        costs.append(\n            pk.costs.pose_cost_analytic_jac(\n                self.robot,\n                JointVar(0),\n                target_L,\n                jnp.array(self.L_ee_link_idx, dtype=jnp.int32),\n                pos_weight=50.0,\n                ori_weight=10.0,\n            )\n        )\n\n    if target_R is not None:\n        costs.append(\n            pk.costs.pose_cost_analytic_jac(\n                self.robot,\n                JointVar(0),\n                target_R,\n                jnp.array(self.R_ee_link_idx, dtype=jnp.int32),\n                pos_weight=50.0,\n                ori_weight=10.0,\n            )\n        )\n\n    costs.append(\n        pk.costs.limit_cost(  # pyright: ignore[reportCallIssue]\n            self.robot, JointVar(0), weight=100.0\n        )\n    )\n\n    if target_Head is not None:\n        costs.append(\n            pk.costs.pose_cost(  # pyright: ignore[reportCallIssue]\n                robot=self.robot,\n                joint_var=JointVar(0),\n                target_pose=target_Head,\n                target_link_index=jnp.array(self.torso_link_idx, dtype=jnp.int32),\n                pos_weight=0.0,\n                ori_weight=jnp.array([0.0, 0.0, 20.0]),\n            )\n        )\n\n    return costs\n</code></pre>"},{"location":"api/#teleop_xr.ik.robots.h1_2.UnitreeH1Robot.forward_kinematics","title":"<code>forward_kinematics(config)</code>","text":"<p>Compute the forward kinematics for the given configuration.</p> Source code in <code>teleop_xr/ik/robots/h1_2.py</code> <pre><code>@override\ndef forward_kinematics(self, config: jax.Array) -&gt; dict[str, jaxlie.SE3]:\n    \"\"\"\n    Compute the forward kinematics for the given configuration.\n    \"\"\"\n    fk = self.robot.forward_kinematics(config)\n    return {\n        \"left\": jaxlie.SE3(fk[self.L_ee_link_idx]),\n        \"right\": jaxlie.SE3(fk[self.R_ee_link_idx]),\n        \"head\": jaxlie.SE3(fk[self.torso_link_idx]),\n    }\n</code></pre>"},{"location":"api/#events-logic","title":"Events &amp; Logic","text":""},{"location":"api/#teleop_xrevents","title":"teleop_xr.events","text":""},{"location":"api/#teleop_xr.events","title":"<code>teleop_xr.events</code>","text":"<p>XR event system types and utilities.</p> <p>This module provides enums and dataclasses for XR button events, including button identification, controller identification, and event data.</p>"},{"location":"api/#teleop_xr.events.ButtonDetector","title":"<code>ButtonDetector</code>","text":"<p>Detects complex button events (double-press, long-press) from raw button states.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>class ButtonDetector:\n    \"\"\"Detects complex button events (double-press, long-press) from raw button states.\"\"\"\n\n    _settings: EventSettings\n    _states: dict[tuple[XRButton, XRController], ButtonState]\n\n    def __init__(self, settings: EventSettings):\n        \"\"\"Initialize the ButtonDetector.\n\n        Args:\n            settings: Configuration settings for event detection.\n        \"\"\"\n        self._settings = settings\n        self._states = {}\n\n    def update(\n        self,\n        button: XRButton,\n        controller: XRController,\n        is_pressed: bool,\n        timestamp_ms: float,\n    ) -&gt; list[ButtonEvent]:\n        \"\"\"Update the state of a button and return any detected events.\n\n        Args:\n            button: The button being updated.\n            controller: The controller the button belongs to.\n            is_pressed: The current raw pressed state of the button.\n            timestamp_ms: The timestamp of the update in milliseconds.\n\n        Returns:\n            A list of ButtonEvent objects detected during this update.\n        \"\"\"\n        key = (button, controller)\n        if key not in self._states:\n            self._states[key] = ButtonState()\n\n        state = self._states[key]\n        events: list[ButtonEvent] = []\n\n        if is_pressed and not state.is_pressed:\n            state.is_pressed = True\n            state.press_time_ms = timestamp_ms\n            state.long_press_fired = False\n            state.double_press_fired = False\n\n            events.append(\n                ButtonEvent(\n                    type=ButtonEventType.BUTTON_DOWN,\n                    button=button,\n                    controller=controller,\n                    timestamp_ms=timestamp_ms,\n                )\n            )\n\n            time_since_last_release = timestamp_ms - state.last_release_time_ms\n            if (\n                state.last_release_time_ms &gt; 0\n                and time_since_last_release &lt; self._settings.double_press_threshold_ms\n            ):\n                state.double_press_fired = True\n                events.append(\n                    ButtonEvent(\n                        type=ButtonEventType.DOUBLE_PRESS,\n                        button=button,\n                        controller=controller,\n                        timestamp_ms=timestamp_ms,\n                    )\n                )\n\n        elif not is_pressed and state.is_pressed:\n            state.is_pressed = False\n            hold_duration = timestamp_ms - state.press_time_ms\n\n            if state.double_press_fired:\n                state.last_release_time_ms = 0.0\n            else:\n                state.last_release_time_ms = timestamp_ms\n\n            events.append(\n                ButtonEvent(\n                    type=ButtonEventType.BUTTON_UP,\n                    button=button,\n                    controller=controller,\n                    timestamp_ms=timestamp_ms,\n                    hold_duration_ms=hold_duration,\n                )\n            )\n\n        elif is_pressed and state.is_pressed and not state.long_press_fired:\n            hold_duration = timestamp_ms - state.press_time_ms\n            if hold_duration &gt;= self._settings.long_press_threshold_ms:\n                state.long_press_fired = True\n                events.append(\n                    ButtonEvent(\n                        type=ButtonEventType.LONG_PRESS,\n                        button=button,\n                        controller=controller,\n                        timestamp_ms=timestamp_ms,\n                    )\n                )\n\n        return events\n</code></pre>"},{"location":"api/#teleop_xr.events.ButtonDetector.__init__","title":"<code>__init__(settings)</code>","text":"<p>Initialize the ButtonDetector.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>EventSettings</code> <p>Configuration settings for event detection.</p> required Source code in <code>teleop_xr/events.py</code> <pre><code>def __init__(self, settings: EventSettings):\n    \"\"\"Initialize the ButtonDetector.\n\n    Args:\n        settings: Configuration settings for event detection.\n    \"\"\"\n    self._settings = settings\n    self._states = {}\n</code></pre>"},{"location":"api/#teleop_xr.events.ButtonDetector.update","title":"<code>update(button, controller, is_pressed, timestamp_ms)</code>","text":"<p>Update the state of a button and return any detected events.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>XRButton</code> <p>The button being updated.</p> required <code>controller</code> <code>XRController</code> <p>The controller the button belongs to.</p> required <code>is_pressed</code> <code>bool</code> <p>The current raw pressed state of the button.</p> required <code>timestamp_ms</code> <code>float</code> <p>The timestamp of the update in milliseconds.</p> required <p>Returns:</p> Type Description <code>list[ButtonEvent]</code> <p>A list of ButtonEvent objects detected during this update.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>def update(\n    self,\n    button: XRButton,\n    controller: XRController,\n    is_pressed: bool,\n    timestamp_ms: float,\n) -&gt; list[ButtonEvent]:\n    \"\"\"Update the state of a button and return any detected events.\n\n    Args:\n        button: The button being updated.\n        controller: The controller the button belongs to.\n        is_pressed: The current raw pressed state of the button.\n        timestamp_ms: The timestamp of the update in milliseconds.\n\n    Returns:\n        A list of ButtonEvent objects detected during this update.\n    \"\"\"\n    key = (button, controller)\n    if key not in self._states:\n        self._states[key] = ButtonState()\n\n    state = self._states[key]\n    events: list[ButtonEvent] = []\n\n    if is_pressed and not state.is_pressed:\n        state.is_pressed = True\n        state.press_time_ms = timestamp_ms\n        state.long_press_fired = False\n        state.double_press_fired = False\n\n        events.append(\n            ButtonEvent(\n                type=ButtonEventType.BUTTON_DOWN,\n                button=button,\n                controller=controller,\n                timestamp_ms=timestamp_ms,\n            )\n        )\n\n        time_since_last_release = timestamp_ms - state.last_release_time_ms\n        if (\n            state.last_release_time_ms &gt; 0\n            and time_since_last_release &lt; self._settings.double_press_threshold_ms\n        ):\n            state.double_press_fired = True\n            events.append(\n                ButtonEvent(\n                    type=ButtonEventType.DOUBLE_PRESS,\n                    button=button,\n                    controller=controller,\n                    timestamp_ms=timestamp_ms,\n                )\n            )\n\n    elif not is_pressed and state.is_pressed:\n        state.is_pressed = False\n        hold_duration = timestamp_ms - state.press_time_ms\n\n        if state.double_press_fired:\n            state.last_release_time_ms = 0.0\n        else:\n            state.last_release_time_ms = timestamp_ms\n\n        events.append(\n            ButtonEvent(\n                type=ButtonEventType.BUTTON_UP,\n                button=button,\n                controller=controller,\n                timestamp_ms=timestamp_ms,\n                hold_duration_ms=hold_duration,\n            )\n        )\n\n    elif is_pressed and state.is_pressed and not state.long_press_fired:\n        hold_duration = timestamp_ms - state.press_time_ms\n        if hold_duration &gt;= self._settings.long_press_threshold_ms:\n            state.long_press_fired = True\n            events.append(\n                ButtonEvent(\n                    type=ButtonEventType.LONG_PRESS,\n                    button=button,\n                    controller=controller,\n                    timestamp_ms=timestamp_ms,\n                )\n            )\n\n    return events\n</code></pre>"},{"location":"api/#teleop_xr.events.ButtonEvent","title":"<code>ButtonEvent</code>  <code>dataclass</code>","text":"<p>Represents a button event with timing information.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>ButtonEventType</code> <p>The type of button event.</p> <code>button</code> <code>XRButton</code> <p>The button that triggered the event.</p> <code>controller</code> <code>XRController</code> <p>The controller (left/right) that triggered the event.</p> <code>timestamp_ms</code> <code>float</code> <p>Unix timestamp in milliseconds when the event occurred.</p> <code>hold_duration_ms</code> <code>float | None</code> <p>Duration the button was held (for release events), or None.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>@dataclass\nclass ButtonEvent:\n    \"\"\"Represents a button event with timing information.\n\n    Attributes:\n        type: The type of button event.\n        button: The button that triggered the event.\n        controller: The controller (left/right) that triggered the event.\n        timestamp_ms: Unix timestamp in milliseconds when the event occurred.\n        hold_duration_ms: Duration the button was held (for release events), or None.\n    \"\"\"\n\n    type: ButtonEventType\n    button: XRButton\n    controller: XRController\n    timestamp_ms: float\n    hold_duration_ms: float | None = None\n</code></pre>"},{"location":"api/#teleop_xr.events.ButtonEventType","title":"<code>ButtonEventType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of button events that can be detected.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>class ButtonEventType(str, Enum):\n    \"\"\"Types of button events that can be detected.\"\"\"\n\n    BUTTON_DOWN = \"button_down\"\n    BUTTON_UP = \"button_up\"\n    DOUBLE_PRESS = \"double_press\"\n    LONG_PRESS = \"long_press\"\n</code></pre>"},{"location":"api/#teleop_xr.events.ButtonState","title":"<code>ButtonState</code>  <code>dataclass</code>","text":"<p>Internal state for tracking a single button.</p> <p>Attributes:</p> Name Type Description <code>is_pressed</code> <code>bool</code> <p>Whether the button is currently pressed.</p> <code>press_time_ms</code> <code>float</code> <p>Timestamp of the last press event.</p> <code>last_release_time_ms</code> <code>float</code> <p>Timestamp of the last release event.</p> <code>long_press_fired</code> <code>bool</code> <p>Whether a long-press event has already been fired for the current press.</p> <code>double_press_fired</code> <code>bool</code> <p>Whether a double-press event was just fired (for debounce).</p> Source code in <code>teleop_xr/events.py</code> <pre><code>@dataclass\nclass ButtonState:\n    \"\"\"Internal state for tracking a single button.\n\n    Attributes:\n        is_pressed: Whether the button is currently pressed.\n        press_time_ms: Timestamp of the last press event.\n        last_release_time_ms: Timestamp of the last release event.\n        long_press_fired: Whether a long-press event has already been fired for the current press.\n        double_press_fired: Whether a double-press event was just fired (for debounce).\n    \"\"\"\n\n    is_pressed: bool = False\n    press_time_ms: float = 0.0\n    last_release_time_ms: float = 0.0\n    long_press_fired: bool = False\n    double_press_fired: bool = False\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor","title":"<code>EventProcessor</code>","text":"<p>Orchestrates event detection and manages subscriptions.</p> <p>This class parses raw XR state dictionaries, feeds them to a ButtonDetector, and invokes registered callbacks when events are detected.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>class EventProcessor:\n    \"\"\"Orchestrates event detection and manages subscriptions.\n\n    This class parses raw XR state dictionaries, feeds them to a ButtonDetector,\n    and invokes registered callbacks when events are detected.\n    \"\"\"\n\n    _detector: ButtonDetector\n    _callbacks: dict[\n        ButtonEventType, list[tuple[Callable, XRButton | None, XRController | None]]\n    ]\n\n    def __init__(self, settings: EventSettings):\n        \"\"\"Initialize the EventProcessor.\n\n        Args:\n            settings: Configuration settings for event detection.\n        \"\"\"\n        self._detector = ButtonDetector(settings)\n        self._callbacks = {t: [] for t in ButtonEventType}\n\n    def on_button_down(\n        self,\n        button: XRButton | None = None,\n        controller: XRController | None = None,\n        callback: Callable[[ButtonEvent], None] | None = None,\n    ) -&gt; None:\n        \"\"\"Register a callback for button down events.\n\n        Args:\n            button: Optional button filter. If set, only events for this button trigger the callback.\n            controller: Optional controller filter. If set, only events for this controller trigger the callback.\n            callback: The function to call when the event occurs.\n        \"\"\"\n        if callback:\n            self._callbacks[ButtonEventType.BUTTON_DOWN].append(\n                (callback, button, controller)\n            )\n\n    def on_button_up(\n        self,\n        button: XRButton | None = None,\n        controller: XRController | None = None,\n        callback: Callable[[ButtonEvent], None] | None = None,\n    ) -&gt; None:\n        \"\"\"Register a callback for button up events.\n\n        Args:\n            button: Optional button filter.\n            controller: Optional controller filter.\n            callback: The function to call when the event occurs.\n        \"\"\"\n        if callback:\n            self._callbacks[ButtonEventType.BUTTON_UP].append(\n                (callback, button, controller)\n            )\n\n    def on_double_press(\n        self,\n        button: XRButton | None = None,\n        controller: XRController | None = None,\n        callback: Callable[[ButtonEvent], None] | None = None,\n    ) -&gt; None:\n        \"\"\"Register a callback for double press events.\n\n        Args:\n            button: Optional button filter.\n            controller: Optional controller filter.\n            callback: The function to call when the event occurs.\n        \"\"\"\n        if callback:\n            self._callbacks[ButtonEventType.DOUBLE_PRESS].append(\n                (callback, button, controller)\n            )\n\n    def on_long_press(\n        self,\n        button: XRButton | None = None,\n        controller: XRController | None = None,\n        callback: Callable[[ButtonEvent], None] | None = None,\n    ) -&gt; None:\n        \"\"\"Register a callback for long press events.\n\n        Args:\n            button: Optional button filter.\n            controller: Optional controller filter.\n            callback: The function to call when the event occurs.\n        \"\"\"\n        if callback:\n            self._callbacks[ButtonEventType.LONG_PRESS].append(\n                (callback, button, controller)\n            )\n\n    def process(self, pose: np.ndarray, xr_state_dict: dict) -&gt; None:\n        \"\"\"Process XR state and trigger events.\n\n        Args:\n            pose: The 4x4 transformation matrix (unused, for Teleop.subscribe compatibility).\n            xr_state_dict: The raw XR state dictionary.\n        \"\"\"\n        timestamp_ms = xr_state_dict.get(\"timestamp_unix_ms\", 0.0)\n        devices = xr_state_dict.get(\"devices\", [])\n\n        for device in devices:\n            if device.get(\"role\") != \"controller\":\n                continue\n\n            handedness = device.get(\"handedness\")\n            try:\n                controller = XRController(handedness)\n            except ValueError:\n                continue\n\n            gamepad = device.get(\"gamepad\")\n            if not gamepad:\n                continue\n\n            buttons = gamepad.get(\"buttons\", [])\n            for i, button_state in enumerate(buttons):\n                button_enum = button_index_to_enum(i)\n                if not button_enum:\n                    continue\n\n                is_pressed = button_state.get(\"pressed\", False)\n                detected_events = self._detector.update(\n                    button_enum, controller, is_pressed, timestamp_ms\n                )\n\n                for event in detected_events:\n                    self._fire_callbacks(event)\n\n    def _fire_callbacks(self, event: ButtonEvent) -&gt; None:\n        \"\"\"Fire all callbacks matching the event filters.\"\"\"\n        for callback, b_filter, c_filter in self._callbacks.get(event.type, []):\n            if (b_filter is None or b_filter == event.button) and (\n                c_filter is None or c_filter == event.controller\n            ):\n                callback(event)\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.__init__","title":"<code>__init__(settings)</code>","text":"<p>Initialize the EventProcessor.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>EventSettings</code> <p>Configuration settings for event detection.</p> required Source code in <code>teleop_xr/events.py</code> <pre><code>def __init__(self, settings: EventSettings):\n    \"\"\"Initialize the EventProcessor.\n\n    Args:\n        settings: Configuration settings for event detection.\n    \"\"\"\n    self._detector = ButtonDetector(settings)\n    self._callbacks = {t: [] for t in ButtonEventType}\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.on_button_down","title":"<code>on_button_down(button=None, controller=None, callback=None)</code>","text":"<p>Register a callback for button down events.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>XRButton | None</code> <p>Optional button filter. If set, only events for this button trigger the callback.</p> <code>None</code> <code>controller</code> <code>XRController | None</code> <p>Optional controller filter. If set, only events for this controller trigger the callback.</p> <code>None</code> <code>callback</code> <code>Callable[[ButtonEvent], None] | None</code> <p>The function to call when the event occurs.</p> <code>None</code> Source code in <code>teleop_xr/events.py</code> <pre><code>def on_button_down(\n    self,\n    button: XRButton | None = None,\n    controller: XRController | None = None,\n    callback: Callable[[ButtonEvent], None] | None = None,\n) -&gt; None:\n    \"\"\"Register a callback for button down events.\n\n    Args:\n        button: Optional button filter. If set, only events for this button trigger the callback.\n        controller: Optional controller filter. If set, only events for this controller trigger the callback.\n        callback: The function to call when the event occurs.\n    \"\"\"\n    if callback:\n        self._callbacks[ButtonEventType.BUTTON_DOWN].append(\n            (callback, button, controller)\n        )\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.on_button_up","title":"<code>on_button_up(button=None, controller=None, callback=None)</code>","text":"<p>Register a callback for button up events.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>XRButton | None</code> <p>Optional button filter.</p> <code>None</code> <code>controller</code> <code>XRController | None</code> <p>Optional controller filter.</p> <code>None</code> <code>callback</code> <code>Callable[[ButtonEvent], None] | None</code> <p>The function to call when the event occurs.</p> <code>None</code> Source code in <code>teleop_xr/events.py</code> <pre><code>def on_button_up(\n    self,\n    button: XRButton | None = None,\n    controller: XRController | None = None,\n    callback: Callable[[ButtonEvent], None] | None = None,\n) -&gt; None:\n    \"\"\"Register a callback for button up events.\n\n    Args:\n        button: Optional button filter.\n        controller: Optional controller filter.\n        callback: The function to call when the event occurs.\n    \"\"\"\n    if callback:\n        self._callbacks[ButtonEventType.BUTTON_UP].append(\n            (callback, button, controller)\n        )\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.on_double_press","title":"<code>on_double_press(button=None, controller=None, callback=None)</code>","text":"<p>Register a callback for double press events.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>XRButton | None</code> <p>Optional button filter.</p> <code>None</code> <code>controller</code> <code>XRController | None</code> <p>Optional controller filter.</p> <code>None</code> <code>callback</code> <code>Callable[[ButtonEvent], None] | None</code> <p>The function to call when the event occurs.</p> <code>None</code> Source code in <code>teleop_xr/events.py</code> <pre><code>def on_double_press(\n    self,\n    button: XRButton | None = None,\n    controller: XRController | None = None,\n    callback: Callable[[ButtonEvent], None] | None = None,\n) -&gt; None:\n    \"\"\"Register a callback for double press events.\n\n    Args:\n        button: Optional button filter.\n        controller: Optional controller filter.\n        callback: The function to call when the event occurs.\n    \"\"\"\n    if callback:\n        self._callbacks[ButtonEventType.DOUBLE_PRESS].append(\n            (callback, button, controller)\n        )\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.on_long_press","title":"<code>on_long_press(button=None, controller=None, callback=None)</code>","text":"<p>Register a callback for long press events.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>XRButton | None</code> <p>Optional button filter.</p> <code>None</code> <code>controller</code> <code>XRController | None</code> <p>Optional controller filter.</p> <code>None</code> <code>callback</code> <code>Callable[[ButtonEvent], None] | None</code> <p>The function to call when the event occurs.</p> <code>None</code> Source code in <code>teleop_xr/events.py</code> <pre><code>def on_long_press(\n    self,\n    button: XRButton | None = None,\n    controller: XRController | None = None,\n    callback: Callable[[ButtonEvent], None] | None = None,\n) -&gt; None:\n    \"\"\"Register a callback for long press events.\n\n    Args:\n        button: Optional button filter.\n        controller: Optional controller filter.\n        callback: The function to call when the event occurs.\n    \"\"\"\n    if callback:\n        self._callbacks[ButtonEventType.LONG_PRESS].append(\n            (callback, button, controller)\n        )\n</code></pre>"},{"location":"api/#teleop_xr.events.EventProcessor.process","title":"<code>process(pose, xr_state_dict)</code>","text":"<p>Process XR state and trigger events.</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>ndarray</code> <p>The 4x4 transformation matrix (unused, for Teleop.subscribe compatibility).</p> required <code>xr_state_dict</code> <code>dict</code> <p>The raw XR state dictionary.</p> required Source code in <code>teleop_xr/events.py</code> <pre><code>def process(self, pose: np.ndarray, xr_state_dict: dict) -&gt; None:\n    \"\"\"Process XR state and trigger events.\n\n    Args:\n        pose: The 4x4 transformation matrix (unused, for Teleop.subscribe compatibility).\n        xr_state_dict: The raw XR state dictionary.\n    \"\"\"\n    timestamp_ms = xr_state_dict.get(\"timestamp_unix_ms\", 0.0)\n    devices = xr_state_dict.get(\"devices\", [])\n\n    for device in devices:\n        if device.get(\"role\") != \"controller\":\n            continue\n\n        handedness = device.get(\"handedness\")\n        try:\n            controller = XRController(handedness)\n        except ValueError:\n            continue\n\n        gamepad = device.get(\"gamepad\")\n        if not gamepad:\n            continue\n\n        buttons = gamepad.get(\"buttons\", [])\n        for i, button_state in enumerate(buttons):\n            button_enum = button_index_to_enum(i)\n            if not button_enum:\n                continue\n\n            is_pressed = button_state.get(\"pressed\", False)\n            detected_events = self._detector.update(\n                button_enum, controller, is_pressed, timestamp_ms\n            )\n\n            for event in detected_events:\n                self._fire_callbacks(event)\n</code></pre>"},{"location":"api/#teleop_xr.events.EventSettings","title":"<code>EventSettings</code>  <code>dataclass</code>","text":"<p>Configuration settings for event detection.</p> <p>Attributes:</p> Name Type Description <code>double_press_threshold_ms</code> <code>float</code> <p>Maximum time between presses to count as double-press.</p> <code>long_press_threshold_ms</code> <code>float</code> <p>Minimum hold time to count as long-press.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>@dataclass\nclass EventSettings:\n    \"\"\"Configuration settings for event detection.\n\n    Attributes:\n        double_press_threshold_ms: Maximum time between presses to count as double-press.\n        long_press_threshold_ms: Minimum hold time to count as long-press.\n    \"\"\"\n\n    double_press_threshold_ms: float = 300\n    long_press_threshold_ms: float = 500\n</code></pre>"},{"location":"api/#teleop_xr.events.XRButton","title":"<code>XRButton</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>XR controller button identifiers following xr-standard gamepad mapping.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>class XRButton(str, Enum):\n    \"\"\"XR controller button identifiers following xr-standard gamepad mapping.\"\"\"\n\n    TRIGGER = \"trigger\"\n    SQUEEZE = \"squeeze\"\n    TOUCHPAD = \"touchpad\"\n    THUMBSTICK = \"thumbstick\"\n    BUTTON_PRIMARY = \"button_primary\"\n    BUTTON_SECONDARY = \"button_secondary\"\n    MENU = \"menu\"\n</code></pre>"},{"location":"api/#teleop_xr.events.XRController","title":"<code>XRController</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>XR controller hand identifiers.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>class XRController(str, Enum):\n    \"\"\"XR controller hand identifiers.\"\"\"\n\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api/#teleop_xr.events.button_index_to_enum","title":"<code>button_index_to_enum(index)</code>","text":"<p>Convert xr-standard gamepad button index to XRButton enum.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Button index from xr-standard gamepad (0-6).</p> required <p>Returns:</p> Type Description <code>XRButton | None</code> <p>Corresponding XRButton enum value, or None if index is invalid.</p> Source code in <code>teleop_xr/events.py</code> <pre><code>def button_index_to_enum(index: int) -&gt; XRButton | None:\n    \"\"\"Convert xr-standard gamepad button index to XRButton enum.\n\n    Args:\n        index: Button index from xr-standard gamepad (0-6).\n\n    Returns:\n        Corresponding XRButton enum value, or None if index is invalid.\n    \"\"\"\n    return _BUTTON_INDEX_MAP.get(index)\n</code></pre>"},{"location":"api/#video-cameras","title":"Video &amp; Cameras","text":""},{"location":"api/#teleop_xrvideo_stream","title":"teleop_xr.video_stream","text":""},{"location":"api/#teleop_xr.video_stream","title":"<code>teleop_xr.video_stream</code>","text":""},{"location":"api/#teleop_xrcamera_views","title":"teleop_xr.camera_views","text":""},{"location":"api/#teleop_xr.camera_views","title":"<code>teleop_xr.camera_views</code>","text":""},{"location":"api/#teleop_xr.camera_views.build_camera_views_config","title":"<code>build_camera_views_config(head=None, wrist_left=None, wrist_right=None, extra_streams=None)</code>","text":"<p>Inputs are optional device specs (int/str/None) Returns dict with keys for provided values only: 'head', 'wrist_left', 'wrist_right', and any extras Each entry is { \"device\":  } If the same device is mapped to multiple views, allow it but emit a logging.warning Source code in <code>teleop_xr/camera_views.py</code> <pre><code>def build_camera_views_config(\n    head=None, wrist_left=None, wrist_right=None, extra_streams: dict | None = None\n) -&gt; dict:\n    \"\"\"\n    Inputs are optional device specs (int/str/None)\n    Returns dict with keys for provided values only: 'head', 'wrist_left', 'wrist_right', and any extras\n    Each entry is { \"device\": &lt;normalized&gt; }\n    If the same device is mapped to multiple views, allow it but emit a logging.warning\n    \"\"\"\n    inputs = {\"head\": head, \"wrist_left\": wrist_left, \"wrist_right\": wrist_right}\n    if extra_streams:\n        inputs.update(extra_streams)\n\n    config = {}\n    device_to_views = {}\n\n    for view_key, raw_value in inputs.items():\n        if raw_value is not None:\n            normalized = parse_device_spec(raw_value)\n            config[view_key] = {\"device\": normalized}\n\n            if normalized not in device_to_views:\n                device_to_views[normalized] = []\n            device_to_views[normalized].append(view_key)\n\n    for device, views in device_to_views.items():\n        if len(views) &gt; 1:\n            logging.warning(\n                f\"Device {device} is mapped to multiple views: {', '.join(views)}\"\n            )\n\n    return config\n</code></pre>"},{"location":"api/#teleop_xr.camera_views.build_video_streams","title":"<code>build_video_streams(camera_views)</code>","text":"<p>Returns { \"streams\": [{\"id\": , \"device\": }, ...] } Preserve stable order: head, wrist_left, wrist_right if present, then others alphabetically Source code in <code>teleop_xr/camera_views.py</code> <pre><code>def build_video_streams(camera_views: dict) -&gt; dict:\n    \"\"\"\n    Returns { \"streams\": [{\"id\": &lt;view_key&gt;, \"device\": &lt;device&gt;}, ...] }\n    Preserve stable order: head, wrist_left, wrist_right if present, then others alphabetically\n    \"\"\"\n    order = [\"head\", \"wrist_left\", \"wrist_right\"]\n    streams = []\n\n    # First, add ordered known keys\n    for view_key in order:\n        if view_key in camera_views:\n            val = camera_views[view_key]\n            # Handle both Pydantic model and dict\n            if hasattr(val, \"device\"):\n                device = val.device\n            else:\n                device = val[\"device\"]\n\n            streams.append({\"id\": view_key, \"device\": device})\n\n    # Then add any other keys alphabetically\n    extra_keys = sorted([k for k in camera_views.keys() if k not in order])\n    for view_key in extra_keys:\n        val = camera_views[view_key]\n        if hasattr(val, \"device\"):\n            device = val.device\n        else:\n            device = val[\"device\"]\n\n        streams.append({\"id\": view_key, \"device\": device})\n\n    return {\"streams\": streams}\n</code></pre>"},{"location":"api/#visualization","title":"Visualization","text":""},{"location":"api/#teleop_xrrobot_vis","title":"teleop_xr.robot_vis","text":""},{"location":"api/#teleop_xr.robot_vis","title":"<code>teleop_xr.robot_vis</code>","text":""},{"location":"api/#teleop_xr.robot_vis.RobotVisModule","title":"<code>RobotVisModule</code>","text":"<p>Module for serving robot visualization assets (URDF, meshes) and broadcasting state.</p> Source code in <code>teleop_xr/robot_vis.py</code> <pre><code>class RobotVisModule:\n    \"\"\"\n    Module for serving robot visualization assets (URDF, meshes) and broadcasting state.\n    \"\"\"\n\n    def __init__(self, app: FastAPI, config: RobotVisConfig):\n        self.app = app\n        self.config = config\n        self.logger = logging.getLogger(\"teleop.robot_vis\")\n        self._setup_routes()\n\n    def _setup_routes(self):\n        @self.app.get(\"/robot_assets/{file_path:path}\")\n        async def get_asset(file_path: str):\n            self.logger.info(f\"Asset request: {file_path}\")\n            full_path = \"\"\n\n            if file_path == \"robot.urdf\":\n                full_path = self.config.urdf_path\n                # If we have a mesh path (repo root), try to rewrite absolute paths in URDF\n                # to be relative, so the frontend can request them via /robot_assets/\n                if self.config.mesh_path:\n                    try:\n                        with open(full_path, \"r\") as f:\n                            content = f.read()\n\n                        mesh_path_abs = Path(self.config.mesh_path).resolve().as_posix()\n                        if not mesh_path_abs.endswith(\"/\"):\n                            mesh_path_abs += \"/\"\n\n                        # Handle both forward and backslashes in URDF\n                        # (Relevant for Windows where raw URDFs might have backslashes)\n                        mesh_path_native = mesh_path_abs.replace(\"/\", os.sep)\n\n                        new_content = content\n                        if mesh_path_abs in new_content:\n                            new_content = new_content.replace(mesh_path_abs, \"\")\n                        if mesh_path_native in new_content:\n                            new_content = new_content.replace(mesh_path_native, \"\")\n\n                        if new_content != content:\n                            return Response(\n                                content=new_content, media_type=\"application/xml\"\n                            )\n                    except Exception as e:\n                        self.logger.warning(f\"Failed to rewrite URDF paths: {e}\")\n                        # Fallback to standard file serving\n\n            elif \"package://\" in file_path:\n                clean_path = file_path.split(\"package://\")[-1]\n\n                # Try ROS 2 resolution\n                resolved = False\n                try:\n                    from ament_index_python.packages import get_package_share_directory\n\n                    parts = clean_path.split(\"/\")\n                    pkg_name = parts[0]\n                    rel_path = \"/\".join(parts[1:])\n                    pkg_path = get_package_share_directory(pkg_name)\n                    ros_path = os.path.join(pkg_path, rel_path)\n                    if os.path.exists(ros_path):\n                        full_path = ros_path\n                        resolved = True\n                except Exception:\n                    pass\n\n                if not resolved:\n                    if self.config.mesh_path:\n                        full_path = os.path.join(self.config.mesh_path, clean_path)\n                    else:\n                        self.logger.warning(\n                            f\"Request for package resource '{file_path}' but 'mesh_path' is not configured.\"\n                        )\n                        full_path = clean_path\n            else:\n                # Try relative to URDF directory first\n                urdf_dir = os.path.dirname(os.path.abspath(self.config.urdf_path))\n                potential_paths = [os.path.join(urdf_dir, file_path)]\n\n                # If mesh_path is configured, try resolving against it\n                if self.config.mesh_path:\n                    potential_paths.append(\n                        os.path.join(self.config.mesh_path, file_path)\n                    )\n\n                full_path = potential_paths[0]\n                for p in potential_paths:\n                    if os.path.exists(p):\n                        full_path = p\n                        break\n\n            if not os.path.exists(full_path):\n                self.logger.warning(f\"Asset not found: {full_path}\")\n                raise HTTPException(\n                    status_code=404, detail=f\"Asset not found: {file_path}\"\n                )\n\n            media_type = None\n            ext = os.path.splitext(full_path)[1].lower()\n            if ext == \".stl\":\n                media_type = \"application/octet-stream\"\n            elif ext == \".dae\":\n                media_type = \"model/vnd.collada+xml\"\n            elif ext == \".obj\":\n                media_type = \"text/plain\"\n            elif ext == \".urdf\":\n                media_type = \"application/xml\"\n            elif ext == \".glb\":\n                media_type = \"model/gltf-binary\"\n            elif ext == \".gltf\":\n                media_type = \"model/gltf+json\"\n\n            return FileResponse(full_path, media_type=media_type)\n\n    def get_frontend_config(self) -&gt; Dict[str, Any]:\n        return {\n            \"urdf_url\": \"/robot_assets/robot.urdf\",\n            \"model_scale\": self.config.model_scale,\n            \"initial_rotation_euler\": self.config.initial_rotation_euler,\n        }\n\n    async def broadcast_state(self, connection_manager: Any, joints: Dict[str, float]):\n        \"\"\"\n        Broadcasts the current joint state to all connected clients.\n\n        Args:\n            connection_manager: The ConnectionManager instance from Teleop class.\n            joints: Dictionary mapping joint names to values (radians/meters).\n        \"\"\"\n        message = {\"type\": \"robot_state\", \"data\": {\"joints\": joints}}\n        await connection_manager.broadcast(json.dumps(message))\n</code></pre>"},{"location":"api/#teleop_xr.robot_vis.RobotVisModule.broadcast_state","title":"<code>broadcast_state(connection_manager, joints)</code>  <code>async</code>","text":"<p>Broadcasts the current joint state to all connected clients.</p> <p>Parameters:</p> Name Type Description Default <code>connection_manager</code> <code>Any</code> <p>The ConnectionManager instance from Teleop class.</p> required <code>joints</code> <code>Dict[str, float]</code> <p>Dictionary mapping joint names to values (radians/meters).</p> required Source code in <code>teleop_xr/robot_vis.py</code> <pre><code>async def broadcast_state(self, connection_manager: Any, joints: Dict[str, float]):\n    \"\"\"\n    Broadcasts the current joint state to all connected clients.\n\n    Args:\n        connection_manager: The ConnectionManager instance from Teleop class.\n        joints: Dictionary mapping joint names to values (radians/meters).\n    \"\"\"\n    message = {\"type\": \"robot_state\", \"data\": {\"joints\": joints}}\n    await connection_manager.broadcast(json.dumps(message))\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#teleop_xrutilsfilter","title":"teleop_xr.utils.filter","text":""},{"location":"api/#teleop_xr.utils.filter","title":"<code>teleop_xr.utils.filter</code>","text":""},{"location":"api/#teleop_xrutilstransform_limiter","title":"teleop_xr.utils.transform_limiter","text":""},{"location":"api/#teleop_xr.utils.transform_limiter","title":"<code>teleop_xr.utils.transform_limiter</code>","text":""},{"location":"api/#teleop_xr.utils.transform_limiter.apply_twist","title":"<code>apply_twist(T, v, w, dt=1.0)</code>","text":"<p>Apply twist (v, w) to transformation T over time dt.</p> Source code in <code>teleop_xr/utils/transform_limiter.py</code> <pre><code>def apply_twist(T, v, w, dt=1.0):\n    \"\"\"Apply twist (v, w) to transformation T over time dt.\"\"\"\n    # Translation update\n    t_new = T[:3, 3] + v * dt\n\n    # Rotation update\n    angle = np.linalg.norm(w)\n    if angle &lt; 1e-8:\n        R_update = np.eye(3)\n    else:\n        axis = w / angle\n        q_update = axangle2quat(axis, angle * dt)\n        R_update = quat2mat(q_update)\n\n    R_new = R_update @ T[:3, :3]\n\n    T_new = np.eye(4)\n    T_new[:3, :3] = R_new\n    T_new[:3, 3] = t_new\n    return T_new\n</code></pre>"},{"location":"api/#teleop_xr.utils.transform_limiter.se3_to_twist","title":"<code>se3_to_twist(T1, T2)</code>","text":"<p>Compute linear and angular velocity from T1 to T2.</p> Source code in <code>teleop_xr/utils/transform_limiter.py</code> <pre><code>def se3_to_twist(T1, T2):\n    \"\"\"Compute linear and angular velocity from T1 to T2.\"\"\"\n    dT = np.linalg.inv(T1) @ T2\n    # Linear velocity\n    v = dT[:3, 3]\n\n    # Angular velocity\n    R = dT[:3, :3]\n    q = mat2quat(R)\n    angle, axis = quat2axangle(q)\n    w = angle * np.array(axis)\n\n    return v, w\n</code></pre>"},{"location":"api/#teleop_xrcommon_cli","title":"teleop_xr.common_cli","text":""},{"location":"api/#teleop_xr.common_cli","title":"<code>teleop_xr.common_cli</code>","text":""},{"location":"api/#ros2-interface","title":"ROS2 Interface","text":""},{"location":"api/#teleop_xrros2cli","title":"teleop_xr.ros2.cli","text":""},{"location":"api/#teleop_xr.ros2.cli","title":"<code>teleop_xr.ros2.cli</code>","text":""},{"location":"api/#teleop_xr.ros2.cli.Ros2CLI","title":"<code>Ros2CLI</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CommonCLI</code></p> Source code in <code>teleop_xr/ros2/cli.py</code> <pre><code>@dataclass\nclass Ros2CLI(CommonCLI):\n    mode: Literal[\"teleop\", \"ik\"] = \"teleop\"\n    \"\"\"Operation mode: ``teleop`` streams raw state, ``ik`` runs the IK solver.\"\"\"\n\n    head_topic: Optional[str] = None\n    wrist_left_topic: Optional[str] = None\n    wrist_right_topic: Optional[str] = None\n\n    extra_streams: Dict[str, str] = field(default_factory=dict)\n\n    frame_id: str = \"xr_local\"\n    publish_hand_tf: bool = False\n\n    robot_class: Optional[str] = None\n    \"\"\"Robot class to load (entry point or module path).\"\"\"\n    robot_args: str = \"{}\"\n    \"\"\"JSON string of arguments passed to the robot constructor.\"\"\"\n    list_robots: bool = False\n    urdf_topic: str = \"/robot_description\"\n    urdf_timeout: float = 5.0\n    no_urdf_topic: bool = False\n    output_topic: str = \"/joint_trajectory\"\n\n    ros_args: List[str] = field(default_factory=list)\n\n    @property\n    def robot_args_dict(self) -&gt; Dict[str, Any]:\n        try:\n            return json.loads(self.robot_args)\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse robot_args: {self.robot_args}\")\n            return {}\n</code></pre>"},{"location":"api/#teleop_xr.ros2.cli.Ros2CLI.mode","title":"<code>mode = 'teleop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Operation mode: <code>teleop</code> streams raw state, <code>ik</code> runs the IK solver.</p>"},{"location":"api/#teleop_xr.ros2.cli.Ros2CLI.robot_args","title":"<code>robot_args = '{}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JSON string of arguments passed to the robot constructor.</p>"},{"location":"api/#teleop_xr.ros2.cli.Ros2CLI.robot_class","title":"<code>robot_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Robot class to load (entry point or module path).</p>"},{"location":"api/#assets-resources","title":"Assets &amp; Resources","text":""},{"location":"api/#teleop_xrram","title":"teleop_xr.ram","text":""},{"location":"api/#teleop_xr.ram","title":"<code>teleop_xr.ram</code>","text":"<p>Robot Asset Manager (RAM) module. Handles fetching and processing robot descriptions (URDF/Xacro) from git.</p>"},{"location":"api/#teleop_xr.ram.from_string","title":"<code>from_string(urdf_content, cache_dir=None)</code>","text":"<p>Save URDF content to a hash-named file, resolve package:// URIs, and auto-detect mesh_path.</p> Source code in <code>teleop_xr/ram.py</code> <pre><code>def from_string(\n    urdf_content: str, cache_dir: Optional[Path] = None\n) -&gt; tuple[Path, Optional[str]]:\n    \"\"\"\n    Save URDF content to a hash-named file, resolve package:// URIs,\n    and auto-detect mesh_path.\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = get_cache_root()\n    else:\n        cache_dir.mkdir(parents=True, exist_ok=True)\n\n    content_hash = hashlib.sha256(urdf_content.encode()).hexdigest()[:12]\n    output_dir = cache_dir / \"processed\"\n    output_dir.mkdir(parents=True, exist_ok=True)\n    output_urdf_path = output_dir / f\"string_{content_hash}.urdf\"\n\n    all_mesh_paths = []\n\n    def resolve_uri(match):\n        pkg_name = match.group(1)\n        sub_path = match.group(2)\n\n        pkg_path = None\n        # 1. Try RAM internal resolver if context is set\n        if _CURRENT_REPO_ROOT:\n            try:\n                pkg_path = _resolve_package(pkg_name)\n            except ValueError:\n                pass\n\n        # 2. Try ament_index_python\n        if pkg_path is None:\n            pkg_path = _get_ros_package_share_directory(pkg_name)\n\n        if pkg_path:\n            abs_path = (Path(pkg_path) / sub_path).resolve().as_posix()\n            all_mesh_paths.append(abs_path)\n            return abs_path\n\n        return match.group(0)\n\n    # We use a slightly more restrictive regex for sub_path to avoid greedy matching\n    # into other URDF attributes, but we stay close to the original pattern.\n    resolved_content = re.sub(\n        r\"package://([^/]+)/([^\\\"&lt;\\s]*)\", resolve_uri, urdf_content\n    )\n\n    # Collect other absolute paths already in URDF\n    for match in re.finditer(r'filename=\"([^\"]+)\"', resolved_content):\n        p = match.group(1)\n        if Path(p).is_absolute() and p not in all_mesh_paths:\n            all_mesh_paths.append(p)\n\n    mesh_path = None\n    if all_mesh_paths:\n        try:\n            mesh_dirs = [os.path.dirname(p) for p in all_mesh_paths]\n            cp = os.path.commonpath(mesh_dirs)\n            if cp not in [\"/\", \"/opt\", \"/usr\", \"/home\"]:\n                mesh_path = cp\n        except ValueError:\n            pass\n\n    output_urdf_path.write_text(resolved_content)\n    return output_urdf_path, mesh_path\n</code></pre>"},{"location":"api/#teleop_xr.ram.get_cache_root","title":"<code>get_cache_root()</code>","text":"<p>Get the root directory for RAM cache.</p> Source code in <code>teleop_xr/ram.py</code> <pre><code>def get_cache_root() -&gt; Path:\n    \"\"\"Get the root directory for RAM cache.\"\"\"\n    cache_root = Path.home() / \".cache\" / \"ram\"\n    cache_root.mkdir(parents=True, exist_ok=True)\n    return cache_root\n</code></pre>"},{"location":"api/#teleop_xr.ram.get_repo","title":"<code>get_repo(repo_url, branch=None, cache_dir=None)</code>","text":"<p>Fetch a git repository into the cache and return its local path.</p> Source code in <code>teleop_xr/ram.py</code> <pre><code>def get_repo(\n    repo_url: str, branch: Optional[str] = None, cache_dir: Optional[Path] = None\n) -&gt; Path:\n    \"\"\"\n    Fetch a git repository into the cache and return its local path.\n    \"\"\"\n    if cache_dir is None:\n        cache_dir = get_cache_root()\n    else:\n        cache_dir.mkdir(parents=True, exist_ok=True)\n\n    repo_dir = _get_repo_dir(repo_url, cache_dir)\n    repo_dir.parent.mkdir(parents=True, exist_ok=True)\n\n    lock_path = repo_dir.with_suffix(\".lock\")\n\n    with FileLock(lock_path):\n        if not repo_dir.exists():\n            # Clone repo\n            repo = git.Repo.clone_from(repo_url, repo_dir, branch=branch)\n            repo.close()\n        else:\n            # Update repo\n            repo = git.Repo(repo_dir)\n            try:\n                if branch:\n                    try:\n                        repo.git.checkout(branch)\n                    except git.GitCommandError:\n                        # If checkout fails, try fetching first\n                        repo.remotes.origin.fetch()\n                        repo.git.checkout(branch)\n\n                repo.remotes.origin.pull()\n            finally:\n                repo.close()\n\n    return repo_dir\n</code></pre>"},{"location":"api/#teleop_xr.ram.get_resource","title":"<code>get_resource(repo_url=None, path_inside_repo='', repo_root=None, branch=None, cache_dir=None, xacro_args=None, resolve_packages=True, convert_dae_to_glb=False)</code>","text":"<p>Main entry point for fetching a robot resource.</p> Source code in <code>teleop_xr/ram.py</code> <pre><code>def get_resource(\n    repo_url: Optional[str] = None,\n    path_inside_repo: str = \"\",\n    repo_root: Optional[Path] = None,\n    branch: Optional[str] = None,\n    cache_dir: Optional[Path] = None,\n    xacro_args: Optional[Dict[str, str]] = None,\n    resolve_packages: bool = True,\n    convert_dae_to_glb: bool = False,\n) -&gt; Path:\n    \"\"\"\n    Main entry point for fetching a robot resource.\n    \"\"\"\n    if not repo_url and not repo_root:\n        raise ValueError(\"Either repo_url or repo_root must be provided\")\n    if repo_url and repo_root:\n        raise ValueError(\"Only one of repo_url or repo_root can be provided\")\n\n    if Path(path_inside_repo).is_absolute():\n        raise ValueError(\"path_inside_repo must be relative\")\n\n    if cache_dir is None:\n        cache_dir = get_cache_root()\n\n    if repo_root:\n        repo_dir = Path(repo_root)\n    else:\n        assert repo_url is not None\n        repo_dir = get_repo(repo_url, branch=branch, cache_dir=cache_dir)\n\n    file_path = repo_dir / path_inside_repo\n\n    if not file_path.exists():\n        msg = f\"Asset {path_inside_repo} not found in \"\n        msg += f\"local path {repo_root}\" if repo_root else f\"repo {repo_url}\"\n        raise FileNotFoundError(msg)\n\n    is_xacro = file_path.suffix == \".xacro\" or \".urdf.xacro\" in file_path.name\n\n    if is_xacro:\n        # Unique name for output based on args and resolution\n        arg_str = str(sorted(xacro_args.items())) if xacro_args else \"\"\n        arg_str += f\"_resolved={resolve_packages}\"\n        arg_str += f\"_glb={convert_dae_to_glb}\"\n\n        if repo_root:\n            # Hash includes absolute repo path to avoid collisions\n            arg_str += f\"_root={repo_dir.absolute()}\"\n            arg_str += f\"_path={path_inside_repo}\"\n\n        arg_hash = hashlib.sha256(arg_str.encode()).hexdigest()[:12]\n\n        if repo_root:\n            output_dir = cache_dir / \"processed\"\n            output_dir.mkdir(parents=True, exist_ok=True)\n            output_urdf_path = output_dir / f\"{file_path.stem}_{arg_hash}.urdf\"\n        else:\n            output_urdf_path = (\n                file_path.parent / f\"{file_path.stem}_{arg_hash[:6]}.urdf\"\n            )\n\n        # Process xacro\n        urdf_content = process_xacro(\n            file_path, repo_dir, mappings=xacro_args, resolve_packages=resolve_packages\n        )\n\n        if convert_dae_to_glb:\n            urdf_content = _replace_dae_with_glb(urdf_content)\n\n        output_urdf_path.write_text(urdf_content)\n    else:\n        # For plain URDF\n        if resolve_packages or convert_dae_to_glb:\n            content = file_path.read_text()\n            needs_processing = False\n\n            if resolve_packages and \"package://\" in content:\n                needs_processing = True\n            if convert_dae_to_glb and \".dae\" in content:\n                needs_processing = True\n\n            if needs_processing:\n                if repo_root:\n                    # Create a processed version in cache for local repos too\n                    output_dir = cache_dir / \"processed\"\n                    output_dir.mkdir(parents=True, exist_ok=True)\n                    # Use a hash to avoid collisions\n                    path_hash = hashlib.sha256(\n                        f\"{repo_dir.absolute()}:{path_inside_repo}:{convert_dae_to_glb}\".encode()\n                    ).hexdigest()[:12]\n                    output_urdf_path = output_dir / f\"{file_path.stem}_{path_hash}.urdf\"\n                else:\n                    suffix = \"_processed_glb\" if convert_dae_to_glb else \"_processed\"\n                    output_urdf_path = (\n                        file_path.parent / f\"{file_path.stem}{suffix}.urdf\"\n                    )\n\n                with _ram_repo_context(repo_dir):\n                    if resolve_packages:\n                        content = _replace_package_uris(content, repo_dir)\n\n                    if convert_dae_to_glb:\n                        content = _replace_dae_with_glb(content)\n\n                output_urdf_path.write_text(content)\n            else:\n                output_urdf_path = file_path\n        else:\n            output_urdf_path = file_path\n\n    return output_urdf_path\n</code></pre>"},{"location":"api/#teleop_xr.ram.process_xacro","title":"<code>process_xacro(xacro_path, repo_root, mappings=None, resolve_packages=True)</code>","text":"<p>Process a xacro file and return the URDF XML string. If resolve_packages is True, package:// URIs are resolved to absolute paths.</p> Source code in <code>teleop_xr/ram.py</code> <pre><code>def process_xacro(\n    xacro_path: Path,\n    repo_root: Path,\n    mappings: Optional[Dict[str, str]] = None,\n    resolve_packages: bool = True,\n) -&gt; str:\n    \"\"\"\n    Process a xacro file and return the URDF XML string.\n    If resolve_packages is True, package:// URIs are resolved to absolute paths.\n    \"\"\"\n    # Use context to allow $(find ...) resolution\n    with _ram_repo_context(repo_root):\n        doc: Any = xacro.process_file(str(xacro_path), mappings=mappings)\n        urdf_xml = doc.toprettyxml(indent=\"  \")\n\n    urdf_xml = _replace_relative_mesh_paths(urdf_xml, xacro_path.parent)\n\n    if resolve_packages:\n        # Also use context here for better package:// resolution\n        with _ram_repo_context(repo_root):\n            return _replace_package_uris(urdf_xml, repo_root)\n    return urdf_xml\n</code></pre>"},{"location":"custom_robots/","title":"Custom Robot Support","text":"<p>TeleopXR supports dynamic loading of custom robot models. For robust management of robot descriptions (URDF/Xacro) and their dependencies, we use the Robot Asset Manager (RAM).</p>"},{"location":"custom_robots/#1-robot-asset-manager-ram","title":"1. Robot Asset Manager (RAM)","text":"<p>RAM simplifies robot integration by automatically cloning repositories, processing Xacro files, and resolving asset paths. It ensures that the IK solver has absolute paths to meshes while the WebXR frontend receives relative paths dynamically rewritten by the visualization server.</p>"},{"location":"custom_robots/#initializing-from-urdf-string-ros-2","title":"Initializing from URDF String (ROS 2)","text":"<p>When integrating with ROS 2, the robot's description is often provided as a string from the <code>/robot_description</code> topic. Use <code>ram.from_string()</code> to save this content to a temporary file, resolve any <code>package://</code> URIs, and automatically detect the common mesh directory.</p>"},{"location":"custom_robots/#example-implementation-with-unified-urdf-support","title":"Example: Implementation with unified URDF support","text":"<pre><code>from teleop_xr import ram\nfrom teleop_xr.ik.robot import BaseRobot, RobotVisConfig\n</code></pre> <p>...</p> <p>When using the ROS2 interface or the demo, you can specify your custom robot:</p> <ul> <li><code>--robot-class</code>: The robot specification. Can be an entry point name (e.g.,   <code>h1</code>, <code>franka</code>, <code>openarm</code>, <code>so101</code>, <code>teaarm</code>) or a full module path   (<code>my_package.robots:MyRobot</code>).</li> <li><code>--robot-args</code>: A JSON string of arguments passed to the robot constructor.</li> <li><code>--list-robots</code>: Lists all registered robots.</li> </ul> <p>Example:</p> <pre><code>python -m teleop_xr.ros2 --mode ik --robot-class \"franka\"\n</code></pre>"},{"location":"custom_robots/#2-baserobot-contract","title":"2. BaseRobot Contract","text":"<p>Custom robot classes must inherit from <code>teleop_xr.ik.robot.BaseRobot</code> and support the following constructor signature:</p> <pre><code>def __init__(self, urdf_string: str | None = None, **kwargs):\n    ...\n</code></pre> <ul> <li><code>urdf_string</code>: If provided (e.g., via ROS2 <code>/robot_description</code>), the   robot should prioritize initializing from this string. If <code>None</code>, it should   fallback to RAM or local files.</li> </ul>"},{"location":"custom_robots/#3-cli-arguments","title":"3. CLI Arguments","text":"<p>When using the ROS2 interface or the demo, you can specify your custom robot:</p> <ul> <li><code>--robot-class</code>: The robot specification. Can be an entry point name   (e.g., <code>h1</code>, <code>franka</code>, <code>openarm</code>, <code>so101</code>, <code>teaarm</code>) or a full module path   (<code>my_package.robots:MyRobot</code>).</li> <li><code>--robot-args</code>: A JSON string of arguments passed to the robot   constructor.</li> <li><code>--list-robots</code>: Lists all registered robots.</li> </ul> <p>Example:</p> <pre><code>python -m teleop_xr.ros2 --mode ik --robot-class \"franka\"\n</code></pre>"},{"location":"custom_robots/#4-entry-points","title":"4. Entry Points","text":"<p>Register your robot in <code>pyproject.toml</code> to make it discoverable by name:</p> <pre><code>[project.entry-points.\"teleop_xr.robots\"]\nmy-robot = \"my_package.robots:MyRobot\"\n</code></pre>"},{"location":"custom_robots/#5-sphere-collision-support","title":"5. Sphere Collision Support","text":"<p>For advanced robots with complex geometries, TeleopXR supports sphere-based collision checking. This provides superior performance and differentiable signed distance fields for IK optimization.</p> <p>See the Sphere Collision Guide for details on how to generate sphere decompositions and integrate them into your robot implementation.</p>"},{"location":"dora/","title":"dora-rs Interface","text":"<p>TeleopXR can be integrated into dora-rs using the dedicated node available in the dora-hub.</p>"},{"location":"dora/#dora-teleopxr-node","title":"Dora TeleopXR Node","text":"<p>The official dora-rs integration provides a high-performance node that bridges WebXR teleoperation data into the dora-rs ecosystem.</p> <p>\ud83d\udc49 dora-teleop-xr README</p> <p>The integration includes:</p> <ul> <li>XR State Streaming: Seamlessly stream headset and controller poses into   your dora-rs graph.</li> <li>WebSocket Gateway: High-performance bridging between WebXR clients and   dora-rs nodes.</li> <li>Configuration: Easy setup via dora-rs YAML descriptors.</li> <li>Low Latency: Optimized for real-time teleoperation with minimal overhead.</li> </ul>"},{"location":"generic/","title":"Generic Python API Guide","text":"<p>TeleopXR provides a pure Python API for integrating WebXR teleoperation into your own projects. This guide covers how to retrieve raw state data, handle button events, visualize robot models, and utilize the modular IK stack.</p>"},{"location":"generic/#1-raw-xrstate-value-retrieval","title":"1. Raw XRState Value Retrieval","text":"<p>To receive real-time data from the XR headset, use the <code>Teleop</code> class. The state is delivered as a dictionary, which can be validated into a structured <code>XRState</code> object for easy access.</p> <pre><code>import numpy as np\nfrom teleop_xr import Teleop, TeleopSettings\nfrom teleop_xr.messages import XRState\n\ndef on_xr_update(pose: np.ndarray, info: dict):\n    \"\"\"\n    Args:\n        pose: 4x4 matrix representing the primary end-effector target.\n        info: Raw dictionary containing all device poses and inputs.\n    \"\"\"\n    try:\n        # Convert dictionary to structured Pydantic model\n        state = XRState.model_validate(info)\n\n        for device in state.devices:\n            print(f\"Device: {device.role}\")\n            print(f\"Position: {device.pose.position}\")\n\n            if device.gamepad:\n                print(f\"Buttons: {len(device.gamepad.buttons)}\")\n                print(f\"Axes: {device.gamepad.axes}\")\n    except Exception as e:\n        print(f\"Error parsing state: {e}\")\n\n# Configure and start\nsettings = TeleopSettings(port=4443, input_mode=\"controller\")\nteleop = Teleop(settings=settings)\nteleop.subscribe(on_xr_update)\nteleop.run()\n</code></pre>"},{"location":"generic/#2-button-event-system","title":"2. Button Event System","text":"<p>TeleopXR includes an <code>EventProcessor</code> that detects complex interactions like double-presses and long-presses, abstracting away the raw boolean polling.</p> <pre><code>from teleop_xr.events import EventProcessor, EventSettings, XRButton, ButtonEventType\n\n# 1. Initialize Processor\nevent_settings = EventSettings(\n    double_press_threshold_ms=300,\n    long_press_threshold_ms=500\n)\nevent_processor = EventProcessor(event_settings)\n\n# 2. Register Callbacks\ndef on_trigger_down(event):\n    print(f\"Trigger pressed on {event.controller}!\")\n\ndef on_primary_double_press(event):\n    print(\"A/X button double-pressed!\")\n\nevent_processor.on_button_down(button=XRButton.TRIGGER, callback=on_trigger_down)\nevent_processor.on_double_press(button=XRButton.BUTTON_PRIMARY, callback=on_primary_double_press)\n\n# 3. Integrate with Teleop\nteleop = Teleop(TeleopSettings())\nteleop.subscribe(event_processor.process)\nteleop.run()\n</code></pre>"},{"location":"generic/#3-robot-model-visualization","title":"3. Robot Model Visualization","text":"<p>You can stream a URDF-based robot model to the WebXR frontend for real-time visualization. This allows the operator to see a \"ghost\" or \"digital twin\" of the robot in VR.</p> <pre><code>from teleop_xr import Teleop, TeleopSettings\nfrom teleop_xr.config import RobotVisConfig\n\n# Configure the robot model\nvis_config = RobotVisConfig(\n    urdf_path=\"path/to/my_robot.urdf\",\n    mesh_path=\"path/to/meshes\",  # Optional: folder containing STLs/OBJs\n    model_scale=1.0,\n    initial_rotation_euler=[0, 0, 0]\n)\n\nsettings = TeleopSettings(robot_vis=vis_config)\nteleop = Teleop(settings=settings)\n\n# To update the visualizer's joint positions:\n# Use teleop.publish_joint_state(joint_positions_dict)\nteleop.run()\n</code></pre>"},{"location":"generic/#4-camera-video-streaming","title":"4. Camera &amp; Video Streaming","text":"<p>TeleopXR can transmit live camera streams from your robot or workstation into the WebXR scene. Define <code>VideoStreamConfig</code> objects for each camera and pass them inside <code>TeleopSettings.video_config</code> so the frontend automatically subscribes to the tracks.</p> <pre><code>from teleop_xr import Teleop, TeleopSettings\nfrom teleop_xr.video_stream import VideoStreamConfig\n\nstream_configs = [\n    VideoStreamConfig(id=\"head\", device=0, width=1280, height=720, fps=30),\n    VideoStreamConfig(id=\"hand\", device=1, width=1280, height=720, fps=30),\n]\n\nsettings = TeleopSettings(\n    video_config={\"streams\": [cfg.model_dump() for cfg in stream_configs]}\n)\nteleop = Teleop(settings=settings)\nteleop.run()\n</code></pre> <p>If you need to feed frames from ROS topics, file playback, or other sources, subclass <code>ExternalVideoSource</code> or call <code>put_frame</code> on it directly to inject numpy arrays into the stream manager.</p>"},{"location":"generic/#5-ik-teleoperation-algorithm","title":"5. IK / Teleoperation Algorithm","text":"<p>The modular IK stack allows you to map 6DoF XR poses directly to robot joint configurations using a JAX-powered optimizer.</p>"},{"location":"generic/#modular-components","title":"Modular Components","text":"<ul> <li><code>BaseRobot</code>: Abstract class where you define your robot's kinematics and   cost functions.</li> <li><code>PyrokiSolver</code>: High-performance solver that executes the optimization.</li> <li><code>IKController</code>: Manages engagement logic (deadman switch) and relative   motion snapshots.</li> </ul>"},{"location":"generic/#implementation-example","title":"Implementation Example","text":"<pre><code>import numpy as np\nfrom teleop_xr.ik import IKController, PyrokiSolver, BaseRobot\n\nclass MyRobotModel(BaseRobot):\n    # Implement the abstract interface for your specific URDF\n    ...\n\nrobot = MyRobotModel()\nsolver = PyrokiSolver(robot)\ncontroller = IKController(robot, solver)\n\n# Initialize state\nq_current = robot.get_default_config()\n\ndef teleop_loop(xr_state):\n    global q_current\n\n    # IKController handles relative motion and deadman logic\n    # Returns optimized joint positions (q)\n    q_new = controller.step(xr_state, q_current)\n\n    q_current = q_new\n    send_to_hardware(q_current)\n</code></pre> <p>For a full reference of classes and methods, please refer to the API Reference.</p>"},{"location":"ros2/","title":"ROS2 Interface","text":"<p>TeleopXR includes a full-featured ROS2 interface that publishes XR state as ROS topics, subscribes to image topics for video streaming, and provides real-time robot visualization in WebXR.</p> <p></p>"},{"location":"ros2/#quick-start","title":"Quick Start","text":"<p>Check out our example ROS2 workspace with a complete MoveIt2 integration:</p> <p>\ud83d\udc49 teleop_xr_ros2_example</p> <p>The example includes:</p> <ul> <li>Pixi &amp; UV environment management</li> <li>Mock hardware for running without a physical robot</li> <li>RViz integration with synchronized robot visualization</li> <li>Ready-to-run demo with Franka Panda</li> </ul>"},{"location":"ros2/#running-the-node","title":"Running the Node","text":"<p>You can run the ROS2 node using the Python module directly. It supports two primary modes: <code>teleop</code> (streaming raw poses) and <code>ik</code> (streaming joint trajectories with IK solver).</p> <pre><code># 1. Standard Teleop Mode (Default)\n# Streams XR poses and controller states to ROS2 topics\npython -m teleop_xr.ros2 --mode teleop\n\n# 2. IK Mode (with default Unitree H1 robot model)\n# Computes joint trajectories using IK solver\npython -m teleop_xr.ros2 --mode ik\n\n# 3. IK Mode with custom robot (e.g., Franka Panda)\n# Automatically fetches URDF from /robot_description topic\npython -m teleop_xr.ros2 \\\n  --mode ik \\\n  --robot-class franka_panda\n\n# 4. IK Mode with custom robot class path\npython -m teleop_xr.ros2 \\\n  --mode ik \\\n  --robot-class teleop_xr.ik.robots.franka:FrankaPandaRobot\n</code></pre>"},{"location":"ros2/#command-line-arguments","title":"Command Line Arguments","text":""},{"location":"ros2/#core-settings","title":"Core Settings","text":"<ul> <li><code>--mode</code>: Operation mode (<code>teleop</code> or <code>ik</code>). Default is <code>teleop</code>.</li> <li><code>--host</code>: Host address (default: <code>0.0.0.0</code>)</li> <li><code>--port</code>: Port number (default: <code>4443</code>)</li> <li><code>--input-mode</code>: Input mode (<code>controller</code>, <code>hand</code>, or <code>auto</code>).</li> </ul>"},{"location":"ros2/#robot-ik-settings-for-mode-ik","title":"Robot &amp; IK Settings (for <code>--mode ik</code>)","text":"<ul> <li><code>--robot-class</code>: Robot class to load. Can be:</li> <li>Entry point name (e.g., <code>franka_panda</code>, <code>unitree_h1</code>)</li> <li>Fully qualified path (e.g., <code>teleop_xr.ik.robots.franka:FrankaPandaRobot</code>)</li> <li>Default: <code>None</code> (uses Unitree H1)</li> <li><code>--robot-args</code>: JSON string of arguments to pass to robot constructor (default:   <code>{}</code>)</li> <li><code>--list-robots</code>: List all available robots registered via entry points and   exit</li> <li><code>--urdf-topic</code>: ROS topic to fetch URDF from (default: <code>/robot_description</code>)</li> <li><code>--urdf-timeout</code>: Timeout for fetching URDF in seconds (default: <code>5.0</code>)</li> <li><code>--no-urdf-topic</code>: Disable automatic URDF fetching from topic</li> <li><code>--output-topic</code>: ROS topic to publish JointTrajectory messages (default:   <code>/joint_trajectory</code>)</li> </ul>"},{"location":"ros2/#frame-tf-settings","title":"Frame &amp; TF Settings","text":"<ul> <li><code>--frame-id</code>: The frame ID for published poses (default: <code>xr_local</code>).</li> <li><code>--publish-hand-tf</code>: If set, publishes TF transforms for individual hand   joints.</li> </ul>"},{"location":"ros2/#video-streaming","title":"Video Streaming","text":"<ul> <li><code>--head-topic</code>: ROS topic for head camera view.</li> <li><code>--wrist-left-topic</code>: ROS topic for left wrist camera view.</li> <li><code>--wrist-right-topic</code>: ROS topic for right wrist camera view.</li> <li><code>--extra-streams</code>: Additional streams in <code>key=topic</code> format.</li> </ul>"},{"location":"ros2/#ros-arguments","title":"ROS Arguments","text":"<ul> <li><code>--ros-args</code>: Additional ROS2 arguments (e.g., parameter overrides)</li> </ul>"},{"location":"ros2/#published-topics","title":"Published Topics","text":"<p>The node publishes the following topics (namespaced under <code>xr/</code>):</p>"},{"location":"ros2/#poses-tracking","title":"Poses &amp; Tracking","text":"<ul> <li><code>xr/head/pose</code> (<code>geometry_msgs/PoseStamped</code>): 6DoF pose of the headset.</li> <li><code>xr/controller_{left|right}/pose</code> (<code>geometry_msgs/PoseStamped</code>): Grip pose of   the controllers.</li> <li><code>xr/hand_{left|right}/joints</code> (<code>geometry_msgs/PoseArray</code>): Array of poses for   all 25 hand joints.</li> </ul>"},{"location":"ros2/#inputs","title":"Inputs","text":"<ul> <li><code>xr/controller_{left|right}/joy</code> (<code>sensor_msgs/Joy</code>): Controller button and   axis states.</li> <li>Buttons: Standard WebXR gamepad button mapping (Trigger, Grip, A/B/X/Y,     Thumbstick Click).</li> <li>Axes: Joystick X/Y axes + Analog values for Trigger/Grip.</li> <li><code>xr/controller_{left|right}/joy_touched</code> (<code>sensor_msgs/Joy</code>):   Touch/capacitive states for buttons.</li> <li><code>xr/events/{event_type}</code> (<code>std_msgs/String</code>): Button events (JSON format) for   <code>button_down</code>, <code>button_up</code>, <code>double_press</code>, <code>long_press</code>.</li> </ul>"},{"location":"ros2/#diagnostics","title":"Diagnostics","text":"<ul> <li><code>xr/fetch_latency_ms</code> (<code>std_msgs/Float64</code>): Latency of fetching XR state on the   headset.</li> </ul>"},{"location":"ros2/#ik-mode-topics-only-in-mode-ik","title":"IK Mode Topics (only in <code>--mode ik</code>)","text":"<ul> <li><code>/joint_trajectory</code> (<code>trajectory_msgs/JointTrajectory</code>): Optimized joint   configuration commands generated by the IK solver.</li> </ul>"},{"location":"ros2/#subscribed-topics","title":"Subscribed Topics","text":""},{"location":"ros2/#ik-mode-only-in-mode-ik","title":"IK Mode (only in <code>--mode ik</code>)","text":"<ul> <li><code>/joint_states</code> (<code>sensor_msgs/JointState</code>): Current robot joint states. Used   to synchronize the internal robot state when IK is not actively engaged.</li> </ul>"},{"location":"ros2/#video-streaming-subscribed","title":"Video Streaming (Subscribed)","text":"<ul> <li>Any topic specified in <code>--head-topic</code>, <code>--wrist-left-topic</code>,   <code>--wrist-right-topic</code>, or <code>--extra-streams</code>.</li> <li>Supports <code>sensor_msgs/Image</code> (raw) and <code>sensor_msgs/CompressedImage</code>   (compressed).</li> <li>Note: Requires <code>cv_bridge</code> for efficient conversion. If <code>cv_bridge</code> is   missing, it falls back to a basic numpy conversion (supporting <code>rgb8</code>, <code>bgr8</code>,   <code>mono8</code>).</li> </ul>"},{"location":"ros2/#urdf-loading-only-in-mode-ik-unless-no-urdf-topic-is-set","title":"URDF Loading (only in <code>--mode ik</code>, unless <code>--no-urdf-topic</code> is set)","text":"<ul> <li><code>/robot_description</code> (or custom topic via <code>--urdf-topic</code>): URDF string for   robot model. Automatically fetched on startup with a <code>TRANSIENT_LOCAL</code> QoS   profile.</li> </ul>"},{"location":"ros2/#tf-transforms","title":"TF Transforms","text":"<p>The node broadcasts TF transforms for:</p> <ul> <li><code>xr/head</code></li> <li><code>xr/controller_left/pose</code></li> <li><code>xr/controller_right/pose</code></li> <li><code>xr/hand_{side}/{joint_name}</code> (Only if <code>--publish-hand-tf</code> is enabled)</li> </ul> <p>All transforms are relative to the frame specified by <code>--frame-id</code> (default: <code>xr_local</code>).</p> <p>Note: PC timestamps are used for TF publishing (instead of headset timestamps) to avoid clock drift issues between the headset and ROS2 system.</p>"},{"location":"ros2/#key-features","title":"Key Features","text":""},{"location":"ros2/#urdf-topic-fetching","title":"URDF Topic Fetching","text":"<p>The ROS2 node can automatically fetch the robot's URDF from a ROS2 topic (default: <code>/robot_description</code>). This enables seamless integration with MoveIt2 and other ROS2 systems that publish robot descriptions.</p> <p>How it works:</p> <ol> <li>On startup, the node subscribes to the URDF topic with a <code>TRANSIENT_LOCAL</code>    QoS profile</li> <li>Waits for the URDF string (default timeout: 5 seconds)</li> <li>Passes the URDF to the robot class, overriding the built-in URDF</li> </ol> <p>Use cases:</p> <ul> <li>MoveIt2 Integration: Automatically use the same URDF as your planning   pipeline</li> <li>Custom Robots: Publish your robot's URDF without modifying TeleopXR   code</li> <li>Dynamic Configuration: Change robot configuration without rebuilding</li> </ul> <p>Example:</p> <pre><code># Terminal 1: Publish your robot URDF\nros2 topic pub /robot_description std_msgs/msg/String \\\n  \"data: '$(cat my_robot.urdf)'\" \\\n  --qos-durability transient_local\n\n# Terminal 2: Run TeleopXR (will automatically fetch the URDF)\npython -m teleop_xr.ros2 --mode ik --robot-class franka_panda\n</code></pre> <p>To disable URDF topic fetching:</p> <pre><code>python -m teleop_xr.ros2 --mode ik --no-urdf-topic\n</code></pre>"},{"location":"ros2/#webxr-robot-visualization","title":"WebXR Robot Visualization","text":"<p>When running in IK mode, the robot visualization in the WebXR interface is automatically synchronized with the robot state:</p> <ol> <li>IK-computed Joint States: When IK is active (grips engaged), the    visualization shows the commanded joint configuration</li> <li>Actual Joint States: When IK is inactive, the visualization shows the    actual robot state from <code>/joint_states</code></li> </ol> <p>This provides real-time visual feedback of both the commanded and actual robot configuration directly in the VR/AR headset.</p>"},{"location":"ros2/#custom-robot-loading","title":"Custom Robot Loading","text":"<p>The node supports loading custom robot classes in multiple ways:</p> <p>1. Entry Point Name (recommended for distributed robots):</p> <pre><code>python -m teleop_xr.ros2 --mode ik --robot-class franka_panda\n</code></pre> <p>2. Fully Qualified Path:</p> <pre><code>python -m teleop_xr.ros2 --mode ik \\\n  --robot-class my_package.robots:MyCustomRobot\n</code></pre> <p>3. List Available Robots:</p> <pre><code>python -m teleop_xr.ros2 --list-robots\n</code></pre> <p>Passing Robot Arguments:</p> <pre><code>python -m teleop_xr.ros2 --mode ik \\\n  --robot-class franka_panda \\\n  --robot-args '{\"gripper\": true, \"collision\": true}'\n</code></pre> <p>For more details on creating custom robots, see the Custom Robots Guide.</p>"},{"location":"ros2/#integration-with-moveit2","title":"Integration with MoveIt2","text":"<p>The ROS2 node integrates seamlessly with MoveIt2:</p> <ol> <li>Joint Trajectory Output: Publishes to <code>/joint_trajectory</code> (or custom    topic via <code>--output-topic</code>)</li> <li>Joint State Synchronization: Subscribes to <code>/joint_states</code> to track    actual robot state</li> <li>URDF Synchronization: Fetches URDF from <code>/robot_description</code> (same    source as MoveIt)</li> <li>WebXR Visualization: Real-time visualization of both commanded and    actual robot state</li> </ol> <p>Example Integration:</p> <pre><code># Terminal 1: Launch MoveIt2 demo\nros2 launch moveit2_tutorials demo.launch.py\n\n# Terminal 2: Launch TeleopXR\npython -m teleop_xr.ros2 \\\n  --mode ik \\\n  --robot-class franka_panda \\\n  --output-topic /joint_trajectory\n</code></pre> <p>See the example workspace for a complete MoveIt2 integration.</p>"},{"location":"ros2/#coordinate-frame-convention","title":"Coordinate Frame Convention","text":"<p>TeleopXR follows standard ROS2 conventions:</p> <ul> <li>Coordinate System: FLU (Forward-Left-Up)</li> <li>WebXR to ROS Conversion: Automatically converts from WebXR RUB   (Right-Up-Back) to ROS FLU</li> <li>Transform Order: Conversion happens before publishing to ROS topics</li> </ul>"},{"location":"ros2/#logging","title":"Logging","text":"<p>The ROS2 node uses <code>loguru</code> internally but bridges all log messages to ROS2's logging system:</p> <ul> <li><code>DEBUG</code> \u2192 <code>get_logger().debug()</code></li> <li><code>INFO</code> \u2192 <code>get_logger().info()</code></li> <li><code>WARNING</code> \u2192 <code>get_logger().warn()</code></li> <li><code>ERROR</code> \u2192 <code>get_logger().error()</code></li> <li><code>CRITICAL</code> \u2192 <code>get_logger().fatal()</code></li> </ul> <p>Logs appear in both:</p> <ol> <li>ROS2 logging system (viewable with <code>ros2 topic echo /rosout</code>)</li> <li>Styled console output (for local debugging)</li> </ol>"},{"location":"ros2/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ros2/#urdf-not-fetched","title":"URDF Not Fetched","text":"<p>Symptom: <code>Failed to fetch URDF from topic</code> warning</p> <p>Solutions:</p> <ol> <li>Check if the URDF topic exists: <code>ros2 topic list | grep robot_description</code></li> <li>Verify the topic has a publisher: <code>ros2 topic info /robot_description</code></li> <li>Increase timeout: <code>--urdf-timeout 10.0</code></li> <li>Check QoS settings: The topic should use <code>TRANSIENT_LOCAL</code> durability</li> </ol>"},{"location":"ros2/#cv_bridge-not-found","title":"<code>cv_bridge</code> Not Found","text":"<p>Symptom: <code>cv_bridge not available</code> error when using compressed images</p> <p>Solution: Install <code>cv_bridge</code>:</p> <pre><code>sudo apt install ros-humble-cv-bridge\n</code></pre>"},{"location":"ros2/#ik-not-engaging","title":"IK Not Engaging","text":"<p>Symptom: No joint trajectory messages published</p> <p>Requirements for IK engagement:</p> <ol> <li>Both controller grips must be fully pressed (Deadman Rule)</li> <li>Controllers must be in a valid IK solution space</li> <li>Robot must have a valid default configuration</li> </ol> <p>Check the logs for messages like <code>\"IK engagement started\"</code>.</p>"},{"location":"ros2/#webxr-visualization-not-updating","title":"WebXR Visualization Not Updating","text":"<p>Symptom: Robot model in headset doesn't move</p> <p>Solutions:</p> <ol> <li>Verify <code>/joint_states</code> topic is publishing: <code>ros2 topic echo /joint_states</code></li> <li>Check that joint names match between robot class and <code>/joint_states</code></li> <li>Ensure you're in IK mode: <code>--mode ik</code></li> </ol>"},{"location":"sphere_collision/","title":"Sphere-Based Collision Support","text":"<p>TeleopXR uses sphere-based collision checking to provide high-performance, differentiable signed distance fields (SDF) for Inverse Kinematics. This approach is superior to primitive mesh collision (like boxes or capsules) for complex robot geometries as it allows the optimizer to smoothly \"push\" links away from each other and the world.</p>"},{"location":"sphere_collision/#1-generating-collision-data","title":"1. Generating Collision Data","text":"<p>The <code>scripts/configure_sphere_collision.py</code> utility is an interactive GUI built with Viser that helps you generate a <code>collision.json</code> file for your robot.</p>"},{"location":"sphere_collision/#running-the-script","title":"Running the Script","text":"<p>Run the script specifying your robot class (as registered in entry points or module path):</p> <pre><code>python scripts/configure_sphere_collision.py --robot-class \"my_robot\"\n</code></pre>"},{"location":"sphere_collision/#phase-1-sphere-generation","title":"Phase 1: Sphere Generation","text":"<p>In the Spheres tab, you configure the volumetric approximation of your robot:</p> <ol> <li>Allocation: Choose between Auto (distributes spheres based on    volume) or Manual (fine-tune per-link budgets).</li> <li>Spherize: Run the generation. This places spheres to cover the    collision meshes of each link.</li> <li>Refine: (Optional) Run the optimization to tighten the sphere coverage    and minimize overlaps.</li> </ol> <p></p>"},{"location":"sphere_collision/#phase-2-collision-pair-calculation","title":"Phase 2: Collision Pair Calculation","text":"<p>Once spheres are generated, move to the Collision tab to identify which link pairs should be checked for collision.</p> <ol> <li>Settings:<ul> <li>Samples: Number of random configurations to test (default 1000).</li> <li>Threshold: Minimum clearance margin (default 0.01m).</li> <li>Threads: Number of parallel processes for calculation.</li> </ul> </li> <li>Calculation: Click Calculate Ignore Pairs. The script identifies     pairs that:<ul> <li>Always collide: Structural components or adjacent links that   provide no useful signal.</li> <li>Never collide: Links that, within their joint limits, never come   close enough to touch.</li> </ul> </li> <li>Manual Overrides: You can manually disable collision checking for     specific links if you know they are safe (e.g., small decorative parts).</li> </ol> <p></p>"},{"location":"sphere_collision/#export","title":"Export","text":"<p>Enter the desired filename (default <code>collision.json</code>) and click Export to JSON. Save this file in your robot's asset directory.</p>"},{"location":"sphere_collision/#2-integrating-with-robot-class","title":"2. Integrating with Robot Class","text":"<p>To use the generated data in the IK solver, update your robot class (inheriting from <code>BaseRobot</code>) to load and pass the data to <code>pyroki</code>.</p>"},{"location":"sphere_collision/#implementation-example","title":"Implementation Example","text":"<p>The following pattern can be used in your robot class:</p> <pre><code>import os\nimport json\nimport pyroki as pk\nfrom teleop_xr.ik.robot import BaseRobot\n\nclass MyRobot(BaseRobot):\n    def __init__(self, urdf_string: str | None = None, **kwargs):\n        # ... load URDF ...\n\n        # Load sphere and ignore pair data\n        collision_data = self._load_collision_data()\n\n        if collision_data is not None:\n            sphere_decomposition, ignore_pairs = collision_data\n            self.robot_coll = pk.collision.RobotCollision.from_sphere_decomposition(\n                sphere_decomposition,\n                urdf,\n                user_ignore_pairs=ignore_pairs,\n                ignore_immediate_adjacents=True,\n            )\n        else:\n            # Fallback to standard URDF primitive collision\n            self.robot_coll = pk.collision.RobotCollision.from_urdf(urdf)\n\n    @staticmethod\n    def _load_collision_data():\n        \"\"\"Helper to load collision.json or fallback to sphere.json\"\"\"\n        import os, json\n        # Adjust path to your asset directory\n        asset_dir = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"assets\",\n            \"my_robot\"\n        )\n\n        collision_path = os.path.join(asset_dir, \"collision.json\")\n        sphere_path = os.path.join(asset_dir, \"sphere.json\")\n\n        try:\n            if os.path.exists(collision_path):\n                with open(collision_path, \"r\") as f:\n                    data = json.load(f)\n                spheres = data[\"spheres\"]\n                ignore_pairs = tuple(\n                    tuple(pair) for pair in data.get(\"collision_ignore_pairs\", [])\n                )\n                return spheres, ignore_pairs\n\n            if os.path.exists(sphere_path):\n                with open(sphere_path, \"r\") as f:\n                    data = json.load(f)\n                return data, ()\n\n        except (json.JSONDecodeError, IOError, KeyError):\n            pass\n\n        return None\n</code></pre>"},{"location":"sphere_collision/#key-components","title":"Key Components","text":"<ul> <li><code>from_sphere_decomposition</code>: Tells <code>pyroki</code> to use your custom spheres   for SDF calculation.</li> <li><code>user_ignore_pairs</code>: Provides the list of links to exclude from   collision checks, significantly improving performance.</li> <li><code>ignore_immediate_adjacents</code>: When <code>True</code>, automatically ignores   parent-child link pairs defined in the URDF.</li> </ul>"}]}